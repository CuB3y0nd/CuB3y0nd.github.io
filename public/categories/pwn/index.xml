<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>PWN - 分类 - CuB3y0nd&#39;s Blog</title>
    <link>https://www.cubeyond.net/categories/pwn/</link>
    <description>PWN - 分类 - CuB3y0nd&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>root@cubeyond.net (CuB3y0nd)</managingEditor>
      <webMaster>root@cubeyond.net (CuB3y0nd)</webMaster><lastBuildDate>Fri, 18 Aug 2023 10:43:24 &#43;0800</lastBuildDate><atom:link href="https://www.cubeyond.net/categories/pwn/" rel="self" type="application/rss+xml" /><item>
  <title>ret2libc</title>
  <link>https://www.cubeyond.net/ret2libc/</link>
  <pubDate>Fri, 18 Aug 2023 10:43:24 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/ret2libc/</guid>
  <description><![CDATA[<p>ret2libc 基于 C 标准库中的 <code>system</code> 函数。该函数会执行传递给它的任何内容，
这使其成为最佳攻击目标。libc 中的另一个内容是字符串 <code>/bin/sh</code> ；如果你将
此字符串传递给 <code>system</code> 函数，它会弹出一个 shell。</p>
<p>这就是它的全部内容——将 <code>/bin/sh</code> 作为参数传递给 <code>system</code> 。</p>]]></description>
</item>
<item>
  <title>攻击调用约定</title>
  <link>https://www.cubeyond.net/exploiting-calling-conventions/</link>
  <pubDate>Fri, 11 Aug 2023 15:31:21 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/exploiting-calling-conventions/</guid>
  <description><![CDATA[<p>利用调用约定。</p>]]></description>
</item>
<item>
  <title>Gadgets</title>
  <link>https://www.cubeyond.net/gadgets/</link>
  <pubDate>Fri, 11 Aug 2023 10:56:47 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/gadgets/</guid>
  <description><![CDATA[<p>Gadgets 是一小段后跟 <code>ret</code> 指令的代码。例如：<code>pop rdi; ret</code> 。我们可以操纵这些
gadgets 的 <code>ret</code> ，将它们串成一个链来完成我们想要做的事情。</p>]]></description>
</item>
<item>
  <title>调用约定</title>
  <link>https://www.cubeyond.net/calling-conventions/</link>
  <pubDate>Wed, 09 Aug 2023 10:16:36 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/calling-conventions/</guid>
  <description><![CDATA[<p>这篇文章将对 32-bit 和 64-bit 的调用约定进行更为深入的探讨。</p>]]></description>
</item>
<item>
  <title>面向返回编程简介</title>
  <link>https://www.cubeyond.net/return-oriented-programming/</link>
  <pubDate>Tue, 08 Aug 2023 22:03:44 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/return-oriented-programming/</guid>
  <description><![CDATA[<p>ROP 的基础是将二进制文件文件本身中已经存在的代码块链接在一起，以便执行你想要
的操作。这通常涉及将参数传递给 <code>libc</code> 中已经存在的函数，例如 <code>system()</code> 。如果你
可以找到命令的位置，例如 <code>cat flag.txt</code>，然后将其 <em>作为参数</em> 传递给 <code>system()</code> 函数，
它将执行该命令并返回输出。一个更危险的命令是 <code>/bin/sh</code>，当 <code>system()</code> 运行它时，
它会为攻击者提供一个 shell，就像我们使用的 shellcode 一样。</p>
<p>然而，这样做并没有看起来那么简单。为了能够正确调用函数，我们首先必须了解如何
向函数传递参数。</p>]]></description>
</item>
<item>
  <title>No eXecute</title>
  <link>https://www.cubeyond.net/no-execute/</link>
  <pubDate>Tue, 08 Aug 2023 20:40:51 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/no-execute/</guid>
  <description><![CDATA[<p>正如你所预料的那样，程序员对于人们可以将自己的指令注入到程序中 <del><em>感到非常高兴（bushi</em></del>
NX 位代表「不可执行」，将内存区域定义为 <strong>指令</strong> 或 <strong>数据</strong>，把需要写入数据的内存
标识为可写，把保存指令的内存标识为可执行，但不会有一块内存同时被标识为可写
和可执行。这意味着你的输入将被存储为 <strong>数据</strong>，任何将其作为指令运行的尝试
都会使程序崩溃，从而有效地阻止 shellcode 。</p>
<p>为了绕过 NX，我们必须使用一种被称为 <strong>ROP</strong> ，Return-Oriented Programming（面向返回
编程）的技术。</p>]]></description>
</item>
<item>
  <title>32-bit vs 64-bit</title>
  <link>https://www.cubeyond.net/32-bit-vs-64-bit/</link>
  <pubDate>Tue, 08 Aug 2023 20:22:13 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/32-bit-vs-64-bit/</guid>
  <description><![CDATA[<p>到目前为止我们所做的一切都适用于 64-bit 和 32-bit；你唯一需要更改的是将 <code>p32()</code>
改为为 <code>p64()</code> ，因为内存地址更长。</p>
<p>然而，两者之间的真正区别在于将参数传递给函数的方式（我们很快就会更仔细地讨论）；
在 32-bit 中，所有参数在调用函数之前都被压入栈。然而，在 64-bit 中，根据调用约定，
前 6 个参数分别存储在寄存器 <code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code> 和 <code>R9</code> 中，如果超过
6 个，还有更多的参数的话则会保存在栈上。</p>]]></description>
</item>
<item>
  <title>NOPs</title>
  <link>https://www.cubeyond.net/nops/</link>
  <pubDate>Tue, 08 Aug 2023 14:29:14 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/nops/</guid>
  <description><![CDATA[<p>由于在调试工具里得到的返回地址和正常运行时并不一致（这是运行时环境变量等因素有所不同造成的），
所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在溢出 Padding 前面填充
若干长度的 NOP 。</p>
<p>NOP，无操作（<strong>N</strong>o <strong>OP</strong>eration）指令的作用正如其名：什么也不做。所以在运行到 NOP 指令的时候
只会使程序计数器加一，而不会发生其它的事情。这是一种可以破解栈随机化的缓冲区溢出攻击方式。
攻击者通过填充字符串注入攻击代码，在实际的攻击代码前注入很长的 NOP 指令序列，只要程序的
控制流指向该序列任意一处，都可以无副作用地跳转到 shellcode 的起始处，这允许我们有更大的
误差范围，因为向前或向后移动几个字节不会影响程序的正常运行。这与直接运行 shellcode 具有
相同的效果。这种 NOP Padding 通常被称为 NOP Slide 或 NOP Sled（俗称「滑雪橇」），因为 EIP
本质上是沿着它们 Slide 的。这样我们就可以通过增加 NOP 填充来试验 shellcode 的起始地址。NOP Sled
可以帮助攻击者提高访问到自己的攻击代码的概率。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5"target="_blank" rel="external nofollow noopener noreferrer">地址空间配置随机化（ASLR）<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 指程序运行时栈的起始地址是随机的，所以程序中存放各函数返回地址
的地址也会发生对应的改变。可防止运行相同程序的相同系统因易预测栈地址而被攻击。</p>
<p>由于栈地址在一定范围的随机性，攻击者不能够知道攻击代码注入的地址，而要执行攻击代码需要将函数
的返回地址更改为攻击代码的地址（可以通过缓冲区溢出的方式篡改函数的返回地址）。所以，只能在一
定范围内（栈随机导致攻击代码地址一定范围内随机）枚举攻击代码的地址（有依据的猜）。</p>
<div class="details admonition info open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-info-circle fa-fw" aria-hidden="true"></i>例子<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">为了尝试破解 $2^{23}$ 的随机化，则需要枚举 $2^{23}$ 个返回地址。而使用 NOP Sled 的方式，
若枚举一个 $2^{8}$ Bytes 的 NOP sled，则只需要枚举 $2^{23} / (2^{8} + 1)$ 个返回地址
即可，因为每次枚举出的地址只要是 $2^{8}$ 中的之一就可以。（攻击代码本身有一个起始地址，
所以为 $255 + 1$）</div>
    </div>
  </div>
<p>不用 NOP Sled，函数返回地址 &mdash;&gt; 攻击代码</br>
使用 NOP Sled，函数返回地址 &mdash;&gt; NOP 序列（顺序执行）直到攻击代码地址</p>
<p>在 intel x86 汇编中，NOP 指令是 <code>\x90</code> 。</p>]]></description>
</item>
<item>
  <title>shellcode</title>
  <link>https://www.cubeyond.net/shellcode/</link>
  <pubDate>Tue, 08 Aug 2023 05:09:08 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/shellcode/</guid>
  <description><![CDATA[<p>在真正的漏洞利用中，你不太可能拥有 <code>win()</code> 函数。shellcode 是一种允许 <strong>运行你自己的
指令</strong> 的方法，使你能够在系统上运行任意命令。</p>
<p><strong>shellcode</strong> 本质上是 <strong>一系列汇编指令</strong>，一旦我们将它输入到二进制文件中，它就会覆盖返回
地址（返回指针）以劫持代码，并执行我们自己的指令。</p>]]></description>
</item>
<item>
  <title>德布鲁因（De Bruijn）序列</title>
  <link>https://www.cubeyond.net/de-bruijn-sequences/</link>
  <pubDate>Tue, 08 Aug 2023 02:30:16 &#43;0800</pubDate>
  <author>CuB3y0nd</author>
  <guid>https://www.cubeyond.net/de-bruijn-sequences/</guid>
  <description><![CDATA[<p><code>n 阶</code> <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence"target="_blank" rel="external nofollow noopener noreferrer">De Bruijn 序列<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 是一个由 <code>n</code> 个不重复的字符组成的字符串序列。这使得查找 EIP
之前的偏移量变得更加简单：我们只需传入 De Bruijn 序列，获取 EIP 中的值并找到
序列中的 <strong>一个可能的匹配</strong> 来计算偏移量。这里将在 <strong>ret2win</strong> 二进制文件上执行此操作。</p>]]></description>
</item>
</channel>
</rss>
